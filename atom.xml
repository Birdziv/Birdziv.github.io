<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>仓颉Ziv</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://writinglife.vip/"/>
  <updated>2018-10-22T14:37:35.300Z</updated>
  <id>http://writinglife.vip/</id>
  
  <author>
    <name>仓颉Ziv</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ArrayList源码阅读笔记</title>
    <link href="http://writinglife.vip/2018/10/03/ArrayList/"/>
    <id>http://writinglife.vip/2018/10/03/ArrayList/</id>
    <published>2018-10-03T14:37:00.000Z</published>
    <updated>2018-10-22T14:37:35.300Z</updated>
    
    <content type="html"><![CDATA[<p>##ArrayList</p><p>###一、ArrayList简介</p><p>####1.1 类继承结构<br><img src="http://ovrlh76oe.bkt.clouddn.com/ArrayList%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Alt Text"></p><p>####1.2 数据结构<br><img src="http://ovrlh76oe.bkt.clouddn.com/ArrayList%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Alt Text"></p><p>###二、源码</p><p>####2.1 注释</p><blockquote><p>可调整大小的List接口的数组实现，实现所有可选列表操作，并允许所有元素，包括null。除了实现List接口之外，该类还提供了一些方法来操纵内部使用的存储列表的数组的大小。 （这个类是大致相当于Vector，不同之处在于它是不同步的）。<br>该size，isEmpty，get，set，iterator和listIterator操作在固定时间内运行。 add操作以摊余常数运行 ，即添加n个元素需要O（n）个时间。 所有其他操作都以线性时间运行（粗略地说）。 与LinkedList实施相比，常数因子较低。<br>每个ArrayList实例都有一个capacity。 capacity是用于存储列表中的元素的数组的大小。 它总是至少与列表大小一样大。 当元素添加到ArrayList时，其容量会自动增长。 没有规定增长政策的细节，除了添加元素具有不变的摊销时间成本。<br>应用程序可以添加大量使用ensureCapacity操作元件的前增大ArrayList实例的容量。 这可能会减少增量重新分配的数量。<br>请注意，此实现不同步。 如果多个线程同时访问ArrayList实例，并且至少有一个线程在结构上修改列表，则必须在外部进行同步。 （结构修改是添加或删除一个或多个元素的任何操作，或明确调整后台数组的大小;仅设置元素的值不是结构修改。）这通常是通过在一些自然地封装了列表。 如果没有这样的对象存在，列表应该使用Collections.synchronizedList方法“包装”。 这最好在创建时完成，以防止意外的不同步访问列表：<br>  List list = Collections.synchronizedList(new ArrayList(…));<br>快速失败：iterator和listIterator会返回快速失败，当迭代器被创建之后，该list的结构又被修改时。只有当迭代器自己修改list结构时（通过迭代器自身的remove或add方法）不会返回快速失败。返回快速失败的表现是抛出ConcurrentModificationException。因此，面对并发修改，迭代器的快速干净的失败（抛出异常）而不是冒着未来不确定性隐藏的风险。<br>请注意，迭代器的快速失败行为无法保证，因为一般来说，在不同步并发修改的情况下，无法做出任何硬性保证。快速失败的迭代器尽力ConcurrentModificationException 。 因此，编写依赖于此异常的程序的正确性将是错误的：迭代器的故障快速行为应仅用于检测错误。<br>这个类是Java Collections Framework的成员</p></blockquote><p>####2.2 定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;<span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></div></pre></td></tr></table></figure></p><p>类定义与类继承结构图是对应的。<br>从中我们可以了解到：</p><ul><li>ArrayList<e>：说明ArrayList支持泛型。</e></li><li>extends AbstractList<e> ：继承了AbstractList。AbstractList提供List接口的骨干实现，以最大限度地减少“随机访问”数据存储（如ArrayList）实现Llist所需的工作。</e></li><li>implements List<e>：实现了List。实现了所有可选列表操作。</e></li><li>implements RandomAccess：表明ArrayList支持快速（通常是固定时间）随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能。</li><li>implements Cloneable：表明其可以调用clone()方法来返回实例的field-for-field拷贝。</li><li>implements java.io.Serializable：表明该类具有序列化功能。</li></ul><p>####2.3 域<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * 初始化默认容量.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 指定该ArrayList容量为0时，返回该空数组。</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 当调用无参构造方法，返回的是该数组。刚创建一个ArrayList 时，其内数据量为0。</span></div><div class="line"><span class="comment">    * 它与EMPTY_ELEMENTDATA的区别就是：该数组是默认返回的，而后者是在用户指定容量为0时返回。</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 保存添加到ArrayList中的元素。</span></div><div class="line"><span class="comment">    * ArrayList的容量就是该数组的长度。</span></div><div class="line"><span class="comment">    * 该值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时，当第一次添加元素进入ArrayList中时，数组将扩容至DEFAULT_CAPACITY。</span></div><div class="line"><span class="comment">    * 被标记为transient，在对象被序列化的时候不会被序列化</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * ArrayList的实际大小（数组包含的元素个数）。</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * <span class="doctag">@serial</span></span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure></p><ul><li>EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA的区别<br>在调用无参构造函数的时候，返回的是后者，在调用指定了容量为0的构造函数时，返回的是前者；两者的初始容量一个为指定的0，一个为DEFAULT_CAPACITY（默认为10）；对于后者，当第一次添加元素时，就会扩容至默认初始容量DEFAULT_CAPACITY。</li><li>ArrayList的capacity和size的区别<br>Capacity是整个数据结构的大小，size是目前存储了多少元素的大小。</li><li>标记为transient的elementData是怎么进行序列化和反序列化的<br>ArrayList自定义了它的序列化和反序列化的方式，详情查看writeObject()和readObject方法。</li></ul><p>####2.4 构造方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * 构造一个指定初始化容量为initialCapacity的空ArrayList</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 如果初始化容量为负</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</div><div class="line"><span class="comment">//指定初始化容量为0，对应的是EMPTY_ELEMENTDATA这个空数组</span></div><div class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                                               initialCapacity);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 构造一个初始化容量为10的空列表</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 构造一个包含指定collection的元素的列表，这些元素的排列是由该collection的迭代器的返回顺序决定的</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        elementData = c.toArray();</div><div class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// replace with empty array.</span></div><div class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>共有三个构造函数</p><ol><li>ArrayList(int initialCapacity)：</li><li>ArrayList()</li><li>ArrayList(Collection&lt;? extends E&gt; c)</li></ol><p>####2.5 核心方法</p><p>#####2.5.1 get(int index)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * Returns the element at the specified position in this list.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span>  index index of the element to return</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> the element at the specified position in this list</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> elementData(index);</div><div class="line">    &#125;</div><div class="line"> <span class="comment">/**</span></div><div class="line"><span class="comment">     * Checks if the given index is in range.  If not, throws an appropriate</span></div><div class="line"><span class="comment">     * runtime exception.  This method does *not* check if the index is</span></div><div class="line"><span class="comment">     * negative: It is always used immediately prior to an array access,</span></div><div class="line"><span class="comment">     * which throws an ArrayIndexOutOfBoundsException if index is negative.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (index &gt;= size)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">    &#125;</div><div class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (E) elementData[index];</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>方法步骤：</p><ol><li>RangeCheck()判断是否越界；</li><li>直接通过数组下标获取元素<br>因为ArrayList的底层实现就是数组，get方法的时间复杂度为O(1)。<br>#####2.5.2 add(E e)<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        elementData[size++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">        modCount++;</div><div class="line"></div><div class="line">        <span class="comment">// overflow-conscious code</span></div><div class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">            grow(minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></div><div class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">        <span class="comment">// overflow-conscious code</span></div><div class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">            newCapacity = minCapacity;</div><div class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">            newCapacity = hugeCapacity(minCapacity);</div><div class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">            Integer.MAX_VALUE :</div><div class="line">            MAX_ARRAY_SIZE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line"><span class="comment">//如果数组是DEFAULTCAPACITY_EMPTY_ELEMENTDATA，则最小扩容的大小为DEFAULT_CAPACITY</span></div><div class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minCapacity;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * The maximum size of array to allocate.</span></div><div class="line"><span class="comment">     * Some VMs reserve some header words in an array.</span></div><div class="line"><span class="comment">     * Attempts to allocate larger arrays may result in</span></div><div class="line"><span class="comment">     * OutOfMemoryError: Requested array size exceeds VM limit</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div></pre></td></tr></table></figure></li></ol><p>add(E e)涉及到了ArrayList的扩容机制，整个方法的步骤如下：<br>1、    ensureExplicitCapacity(int minCapacity)：modCount++，modCount是父类AbstractList的变量，用于保存数据结构的结构修改次数。当添加一个元素之后的元素个数大于当前数组的容量时，进行扩容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">            grow(minCapacity);</div></pre></td></tr></table></figure></p><p>2、grow(int minCapacity)：扩容机制：将现数组的长度增加到1.5倍，然后取所需的长度（minCapacity）和增加到1.5倍的长度的较大值为新数组的长度；在此之前，判断这个新数组长度是否超过了ArrayList所允许的长度最大值即MAX_ARRAY_SIZE（定义private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;）超过的话就采用Integer.MAX_VALUE</p><p>#####2.5.3 add(int index, E e)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 在指定位置插入元素，然后将当前位置和其往后的元素向后移一位</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> element element to be inserted</span></div><div class="line"><span class="comment">   * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line"><span class="comment">//1、越界检查</span></div><div class="line">      rangeCheckForAdd(index);</div><div class="line"></div><div class="line"><span class="comment">//2、空间检查，是否需要扩容</span></div><div class="line">      ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line"><span class="comment">//arraycopy(Object src,  int  srcPos,Object dest, int destPos,int length)：</span></div><div class="line"><span class="comment">//将src从srcPos位置往后的length长度的元素复制到dest中，从destPos位置开始</span></div><div class="line"><span class="comment">//结果就是将index和其往后的元素向后移一位并且空出了indx位置</span></div><div class="line">      System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                       size - index);</div><div class="line">      elementData[index] = element;</div><div class="line">      size++;</div><div class="line">  &#125;</div><div class="line"> <span class="comment">/**</span></div><div class="line"><span class="comment">   * A version of rangeCheck used by add and addAll.</span></div><div class="line"><span class="comment">*检查index位置是否合法</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>add(int index E e)需要先对元素进行移动，然后完成插入操作，意味着需要O(n)。</p><p>#####2.5.4 remove(int index)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 删除指定位置的元素并返回该元素，并将该位置之后的元素向左移一位</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> index the index of the element to be removed</span></div><div class="line"><span class="comment">   * <span class="doctag">@return</span> the element that was removed from the list</span></div><div class="line"><span class="comment">   * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line"><span class="comment">//1、检查index是否越界</span></div><div class="line">      rangeCheck(index);</div><div class="line"></div><div class="line"><span class="comment">//2、结构修改都要在modCount上加1，添加元素的方法这个语句在调用的ensureExplicitCapacity()方法中</span></div><div class="line">      modCount++;</div><div class="line">      E oldValue = elementData(index);</div><div class="line"></div><div class="line">      <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line"><span class="comment">//3、将该位置之后的元素向左移一位</span></div><div class="line">          System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                           numMoved);</div><div class="line"><span class="comment">//4、置为null，GC会对这块进行回收</span></div><div class="line">      elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line"></div><div class="line">      <span class="keyword">return</span> oldValue;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>注意：为了让GC起作用，必须显式的为最后一个位置赋null值。上面代码中如果不手动赋null值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。<br>由于删除指定位置元素需要将后面的元素左移一位，因此时间复杂度为O(n)</p><p>#####2.5.5 remove(Object o)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 如果list中存在o，删除第一个出现的o；如果不存在，list不变</span></div><div class="line"><span class="comment">   *存在并且删除成功返回true,否则返回false</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> o element to be removed from this list, if present</span></div><div class="line"><span class="comment">   * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line"><span class="comment">//1、判断o是否为null，null不能使用.equals()方法</span></div><div class="line">      <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">              <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="comment">//2、调用快速删除方法</span></div><div class="line">                  fastRemove(index);</div><div class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">              &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">              <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</div><div class="line">                  fastRemove(index);</div><div class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">              &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * Private remove method that skips bounds checking and does not</span></div><div class="line"><span class="comment">   * return the value removed.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">      modCount++;</div><div class="line">      <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">          System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                           numMoved);</div><div class="line">      elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>####2.6 经常调用的方法</p><p>#####2.6.1 System.arraycopy(Object src, int srcPos, Object dest, int desPos, int length)<br>其中：src表示源数组，srcPos表示源数组要复制的起始位置，desc表示目标数组，length表示要复制的长度。该方法实现的是浅复制，即只复制引用。</p><p>#####2.6.2 Arrays.copyOf()<br>Array.copyOf() 用于复制指定的数组内容以达到扩容的目的，该方法对不同的基本数据类型都有对应的重载方法。<br>本文只介绍其中的copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType)方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *复制指定的数组, 如有必要用 null 截取或填充，以使副本具有指定的长度</span></div><div class="line"><span class="comment"> * 对于所有在原数组和副本中都有效的索引，这两个数组相同索引处将包含相同的值</span></div><div class="line"><span class="comment"> * 对于在副本中有效而在原数组无效的所有索引，副本将填充 null，当且仅当指定长度大于原数组的长度时，这些索引存在</span></div><div class="line"><span class="comment"> * 返回的数组属于 newType 类</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> original 要复制的数组</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> 副本的长度</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> 副本的类</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> 原数组的副本，截取或用 null 填充以获得指定的长度</span></div><div class="line"><span class="comment"> * <span class="doctag">@throws</span> NegativeArraySizeException 如果 newLength 为负</span></div><div class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果 original 为 null</span></div><div class="line"><span class="comment"> * <span class="doctag">@throws</span> ArrayStoreException 如果从 original 中复制的元素不属于存储在 newType 类数组中的运行时类型</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</div><div class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]</div><div class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</div><div class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</div><div class="line">                     Math.min(original.length, newLength));</div><div class="line">    <span class="keyword">return</span> copy;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>####2.7 核心方法的时间复杂度<br><img src="http://ovrlh76oe.bkt.clouddn.com/ArrayList%E6%96%B9%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="Alt Text"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##ArrayList&lt;/p&gt;
&lt;p&gt;###一、ArrayList简介&lt;/p&gt;
&lt;p&gt;####1.1 类继承结构&lt;br&gt;&lt;img src=&quot;http://ovrlh76oe.bkt.clouddn.com/ArrayList%E7%B1%BB%E7%BB%93%E6%9E%
      
    
    </summary>
    
      <category term="学习" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="编程" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java源码阅读" scheme="http://writinglife.vip/tags/Java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>写在实习的第一个月，秋招的起点</title>
    <link href="http://writinglife.vip/2018/08/04/%E5%86%99%E5%9C%A8%E5%AE%9E%E4%B9%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%88/"/>
    <id>http://writinglife.vip/2018/08/04/写在实习的第一个月/</id>
    <published>2018-08-04T10:38:26.000Z</published>
    <updated>2018-08-04T10:50:20.842Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2018年8月4号，来到京东实习刚好一个月。觉得有必要写点什么，作为对自己的一个交代。希望自己以后想要回忆这段时光的时候，能再通过这篇文章，看看当时的自己。</p><p>读书十八载，一直在学校里待着，从来也没有真正进入社会，在公司里工作过。当我接到京东实习通过的消息，联系人问我，想什么时候到岗，我的回答是，越早越好。实际上，自己想出去看看的愿望也一直很久了吧。期待，兴奋，开心，担心，不够自信，明知会遇到很多难题但是还是想冲破一切用尽全力去看，去体验的心情，也许这会是我那个时期才会有的一种人生体验吧。</p><p>如愿以偿，完成了入职手续，在走廊中等待助理带我进工位的时候，又偶遇了当时一面面试我的面试官，见到他真的很开心。其实自己原来对京东的印象也不是特别好，但是在和他交流了两个小时后，真的对公司的看法有了很大的改观。心里想着，要是能进来实习，并且由他在实习阶段指导我就完美了。没想到，我也通过了接下来的面试，而更惊喜的是，潮哥指定师傅的时候，刚好指定的是晋龙。到现在为止的这一个月，真的多亏了他，让我学会了很多；也多亏了他和其他几个小伙伴，让我觉得在这里工作，是一件舒服，开心的事。</p><p>这段时间，我真正从象牙塔走出来，也真正地将自己的所学，运用到企业级的项目之中。最开始做的第一个小任务，利用zookeeper实现worker分片管理，一方面让我熟悉了zookeeper，另一方面，也让我对整个HTTP的流程有了直观和深入的了解。第二个任务，是配置项目的jenkins+jdos测试、预发、生产环境。第三个，是开始接触到业务层面的，写项目中一些接口。在晚上回到学校之后，利用了不多的时间，将项目中接触到的springBoot，Dubbo这些工具的原理和使用学会了。相比较与以前的学习，现在在实习阶段的学习，更有目标性，更有积极性，也更能在最快的时间锻炼自己的学习能力，并将所学的东西通过实践来验证。</p><p>觉得自己真的很幸运，能够遇到一个这么认真指导自己的领路人，生活之中，也和晋龙，立阳，立兵这些同事们成为很好的朋友。以前总有人告诉我，职场上有些明争暗斗什么的。说句心里话，我并不惧怕这些，但是也不希望自己遇到这样的情况。还是很享受能在一个团队中，大家一起完后一件事的感觉，然后大家都能得到成长。</p><p>秋招已经全面爆发了，现在自己每天都抓紧自己的一切时间，努力地充实自己。还是想认认真真参加秋招，完成每一场面试。不管会得到什么样的结果，不能让自己后悔。活到现在，好像真正让自己后悔的事情，就是以前有段时间不够努力。不求比别人强，只求让自己能够对自己满意，让自己看得起自己，让自己能悦纳现在的自己。</p><p>以前所说的未来，就是现在了。最后，还是那句话，送给自己：</p><blockquote><p>我们现在所遇到的所有压力，都不能称之为压力，而应该称之为挑战！</p></blockquote><p>少年，你想要什么？Go for it!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是2018年8月4号，来到京东实习刚好一个月。觉得有必要写点什么，作为对自己的一个交代。希望自己以后想要回忆这段时光的时候，能再通过这篇文章，看看当时的自己。&lt;/p&gt;
&lt;p&gt;读书十八载，一直在学校里待着，从来也没有真正进入社会，在公司里工作过。当我接到京东实习通过的消息
      
    
    </summary>
    
      <category term="生活" scheme="http://writinglife.vip/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="总结" scheme="http://writinglife.vip/categories/%E7%94%9F%E6%B4%BB/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="生活" scheme="http://writinglife.vip/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java核心技术36讲——第1讲 | 谈谈对Java平台的理解</title>
    <link href="http://writinglife.vip/2018/08/03/%E5%AF%B9Java%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://writinglife.vip/2018/08/03/对Java平台的理解/</id>
    <published>2018-08-03T13:38:26.000Z</published>
    <updated>2018-08-02T16:10:32.563Z</updated>
    
    <content type="html"><![CDATA[<p>###Java核心技术36讲——第1讲 | 谈谈对Java平台的理解</p><ul><li>宏观上<br>宏观上看，Java平台显著的几个方面有：<ul><li>Java面向对象，以及三大特性：封装、继承、多态；</li><li>Java语言的特性，包括泛型、Lombda表达式等；</li><li>Java一些类包，包括集合、IO/NIO，并发，网络等；</li><li>Java跨平台特性：write onece, run anywhere;</li><li>Java的GC</li><li>……</li></ul></li><li>微观上<br>是对宏观各个点的展开，其实上面的每一个点都有对应的很多小知识点。实际上这个问题本来就是一个很笼统的问题，主要想让自己从一个比较系统的角度去思考Java平台，先系统，再深入。<br>首先明确几个概念：<ul><li>JRE：JRE（Java Runtime Environment），即Java运行环境，包含了JVM和Java类库，以及一些模块等；</li><li>JDK：JDK（Java Development Kit），可以看做是一个JRE的超集，提供了更多工具，如编译器，诊断工具等。</li><li>JVM： Java虚拟机</li></ul></li></ul><p>JVM是Java语言得以跨平台执行的基础，Java跨平台并不真的是Java语言可以跨平台，而是因为JVM屏蔽了操作系统和硬件对语言造成的干扰，可以理解为一种解耦合的思想。以前语言（C++/C）在编码时需要考虑到操作系统和硬件等问题，而Java是运行在JVM上的，JVM与操作系统有关，而Java语言可以与操作系统实现解耦了。</p><ul><li>Java是解释执行吗？<br>这句话并不准确。程序从源代码到运行的三个阶段：编码–编译–运行–调试。Java分为编译期和运行时，Java程序从编码到运行的过程是这样：<ul><li>编译：Javac将Java源码编译成.class文件，也就是字节码，字节码是可以在JVM上到处运行的文件，也即实现了Java的跨平台。实际上从这里也可以看出来，JVM上运行的是字节码文件，所以其它语言，如果能编译成字节码文件，在符合JVM执行规范的前提下，也是可以在JVM上运行的。</li><li>运行：运行分为多种情况，包括解释执行和编译执行，这些运行模式，可以在Java虚拟机启动时，通过指定不同的参数进行选择。<ol><li>解释执行：指定运行参数为”-Xint”，此时解释器（Interpreter）是逐条读入，逐条解释，运行代码。解释器的工作理解为，逐条读入字节码，解释为机器码，再执行机器码，机器码不做保存。这些程序员并不能感知到（像第一次编译是可以得到.class文件的，而这次是直接得到结果）</li><li>编译执行：指定运行参数为”-Xcomp”，此时JVN关闭解释器，不做解释执行，只做编译执行，结果是会导致JVM启动变慢很多。同时有些JIT编译器的优化方式，比如分支预测，如果不进行profiling，往往不能进行有效优化。</li><li>混合模式：指定运行参数为”-Xmixed”，JDK8实际上就是解释和编译混合的一种模式。这里会用到JIT（Just In Time）动态编译器。JVM会对利用JIT对热点代码（编译好的字节码）进行编译，将编译的结果保存为机器码文件（看作是缓存），这样下次再遇到热点代码时，直接执行编译好的机器码文件，而不用再次进行编译执行。这样做的理由是，根据“二八定律”—消耗大部分系统资源的只有那一小部分的热点代码。</li><li>AOT（Ahead of Time Complication），JDK9支持的，它是直接将字节码变异成机器码，这样就避免了JIT预热等各方面的开销。JDK支持AOT和分层编译协作使用，二者并不是二选一的关系</li></ol></li></ul></li></ul><p>其实好像编译执行之于混合模式就像AOT之于JIT，两对并不是从一个层面进行阐述的，对于JIT，它是方法级别的。<br>有这样一些有趣的类比：</p><ol><li>解释执行是“同声传译”，编译执行是“放录”</li><li>写个程序直接执行字节码就是解释执行；运行时把字节码动态翻译成机器码就是JIT；把Java源代码直接翻译成机器码就是AOT。</li></ol><ul><li>扩展<br>能够扩展的地方还有很多，比如类加载过程，类加载器的种类，常见的垃圾收集器等，但无法在一篇文章中总结的很细致。本文的重点<ul><li>对Java平台有个系统性的概念和认识</li><li>对Java从编译到执行有具体的认识，掌握解释执行和编译执行，JIT,AOT等</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###Java核心技术36讲——第1讲 | 谈谈对Java平台的理解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宏观上&lt;br&gt;宏观上看，Java平台显著的几个方面有：&lt;ul&gt;
&lt;li&gt;Java面向对象，以及三大特性：封装、继承、多态；&lt;/li&gt;
&lt;li&gt;Java语言的特性，包括泛型、Lom
      
    
    </summary>
    
      <category term="学习" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Java" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/Java/"/>
    
    
      <category term="Java核心技术36讲" scheme="http://writinglife.vip/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF36%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>树面试题</title>
    <link href="http://writinglife.vip/2018/05/03/%E5%89%91%E6%8C%87-%E6%A0%91/"/>
    <id>http://writinglife.vip/2018/05/03/剑指-树/</id>
    <published>2018-05-03T05:13:26.000Z</published>
    <updated>2018-05-03T14:34:47.076Z</updated>
    
    <content type="html"><![CDATA[<p>#####树<br>面试题7：重建二叉树<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for binary tree</span></div><div class="line"><span class="comment"> * public class TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode left;</span></div><div class="line"><span class="comment"> *     TreeNode right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</div><div class="line">        <span class="comment">//特殊输入</span></div><div class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span> || pre.length &lt;= <span class="number">0</span> || in == <span class="keyword">null</span> || in.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> helper(pre,in,<span class="number">0</span>,<span class="number">0</span>,in.length-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//辅助函数</span></div><div class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in, <span class="keyword">int</span> preStart, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span></span>&#123;</div><div class="line">        <span class="comment">//递归出口</span></div><div class="line">        <span class="keyword">if</span>(preStart &gt; pre.length - <span class="number">1</span> || inStart &gt; inEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(pre[preStart]);</div><div class="line">        <span class="comment">//找到pre[preStart]在in[]中位置</span></div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(in[i] == pre[preStart])&#123;</div><div class="line">                index = i;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        node.left = helper(pre,in,preStart+<span class="number">1</span>,inStart,index-<span class="number">1</span>);</div><div class="line">        node.right = helper(pre,in,preStart+index-inStart+<span class="number">1</span>,index+<span class="number">1</span>,inEnd);</div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>一定注意helper函数中的递归出口，写递归是一定要记得写递归出口的。这里的递归出口是前序遍历或者中序遍历集合全部遍历结束了，即表明重建结束。</p><p>面试题26：树的子结构<br>方法一：常规的思路，二叉树遍历+匹配<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>; <span class="comment">//默认为false，有一个为空的时候</span></div><div class="line">        <span class="comment">//当两个树都不为空时才进行比较</span></div><div class="line">        <span class="keyword">if</span>(root1 != <span class="keyword">null</span> &amp;&amp; root2 != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="comment">//以这个根节点为起点判断是否包含root2</span></div><div class="line">            <span class="keyword">if</span>(root1.val == root2.val) res = ifTree1HaveTree2(root1,root2);</div><div class="line">            <span class="comment">//根节点不相同就往左子树走</span></div><div class="line">            <span class="keyword">if</span>(!res) res = HasSubtree(root1.left,root2);</div><div class="line">            <span class="comment">//都不存在再往右子树走</span></div><div class="line">            <span class="keyword">if</span>(!res) res = HasSubtree(root1.right,root2);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ifTree1HaveTree2</span><span class="params">(TreeNode root1, TreeNode root2)</span></span>&#123;</div><div class="line">        <span class="comment">//root2已经遍历结束都能对应上则返回true</span></div><div class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="comment">//root1已经遍历完，root2还没，则返回false</span></div><div class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//有一个节点没对应上，false</span></div><div class="line">        <span class="keyword">if</span>(root1.val != root2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//根节点对应上了则去对比左右子树</span></div><div class="line">        <span class="keyword">return</span> ifTree1HaveTree2(root1.left, root2.left) &amp;&amp; ifTree1HaveTree2(root1.right, root2.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>方法二：二叉树序列化+KMP算法<br>首先将二叉树进行序列化，得到两个二叉树的序列，然后根据KMP算法判断A序列是否包含B序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IdenticalTree</span><span class="params">(TreeNode A, TreeNode B)</span></span>&#123;</div><div class="line">    <span class="comment">//特殊输入</span></div><div class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//序列化二叉树A和B</span></div><div class="line">        StringBuilder Astr = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</div><div class="line">        StringBuilder Bstr = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</div><div class="line">        Serialize(A, Astr);</div><div class="line">        Serialize(B, Bstr);</div><div class="line">        <span class="comment">//序列化之后运用KMP算法判断A是否包含A</span></div><div class="line">        <span class="comment">//得到B的next数组</span></div><div class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[Bstr.length()+<span class="number">1</span>];</div><div class="line">        next = getNext(Bstr, next);</div><div class="line">        <span class="comment">//开始匹配</span></div><div class="line">        <span class="keyword">int</span> res = match(Astr, Bstr, next);</div><div class="line">        <span class="keyword">return</span> (res &gt; -<span class="number">1</span>) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//序列化二叉树的函数</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Serialize</span><span class="params">(TreeNode root, StringBuilder str)</span></span>&#123;</div><div class="line">    <span class="comment">//递归结束的边界条件</span></div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">        str.append(<span class="string">"#,"</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">            <span class="comment">//#表示空， ","表示结束</span></div><div class="line">        &#125;</div><div class="line">        str.append(root.val + <span class="string">","</span>);</div><div class="line">        Serialize(root.left, str);</div><div class="line">        Serialize(root.right,str);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//KMP算法实现,首先要计算next数组，针对目标字符串</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] getNext(String P， <span class="keyword">int</span> next[])&#123;</div><div class="line">    <span class="keyword">int</span> p_len = P.length();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;</div><div class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; p_len)&#123;</div><div class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || p.charAt(i) == p.charAt(j))&#123;</div><div class="line">            i++;</div><div class="line">                j++;</div><div class="line">                next[i] = j;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;j = next[j];&#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//字符串匹配</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">match</span><span class="params">(String A, String B, <span class="keyword">int</span> next[])</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">//分别表示A和B的下标</span></div><div class="line">        <span class="keyword">while</span>(i &lt; A.length() &amp;&amp; j &lt; B.length())&#123;</div><div class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || A.charAt(i) == B.charAt(j))&#123; <span class="comment">//j == -1:第一个字符不匹配或者A</span></div><div class="line">            i++;</div><div class="line">                j++;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">            j = next[j];<span class="comment">//next[j]可能为-1</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(j == B.length()) <span class="comment">// 匹配成功</span></div><div class="line">        <span class="keyword">return</span> i - j;<span class="comment">//返回位置</span></div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//匹配失败</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>KMP算法：<a href="https://segmentfault.com/a/1190000008575379" target="_blank" rel="external">https://segmentfault.com/a/1190000008575379</a><br>面试题27：二叉树镜像<br>分析：首先前序遍历二叉树，如果节点为空或者左右子树均为空则返回。<br>然后交换左子树和右子树，接着再各自递归。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        TreeNode temp = root.left;</div><div class="line">        root.left = root.right;</div><div class="line">        root.right = temp;</div><div class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</div><div class="line">            Mirror(root.right);</div><div class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</div><div class="line">            Mirror(root.left);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>面试题32：从上往下打印二叉树<br>分析：二叉树的遍历问题，一般使用队列解决<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</div><div class="line">        <span class="comment">//Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); //创建一个queue保存每次输出的节点</span></div><div class="line">        ArrayList&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</div><div class="line">        queue.add(root);</div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            <span class="comment">//计算此时queue的大小，以控制下面的出队循环</span></div><div class="line">            <span class="keyword">int</span> queueSize = queue.size();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queueSize; i++)&#123;</div><div class="line">                TreeNode temp = queue.remove(<span class="number">0</span>);</div><div class="line">                res.add(temp.val);</div><div class="line">                <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>) queue.add(temp.left);</div><div class="line">                <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>) queue.add(temp.right);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>面试题33：二叉搜索树的后序遍历<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(sequence.length==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span>(sequence.length==<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> ju(sequence, <span class="number">0</span>, sequence.length-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">     <span class="comment">//因为涉及到了递归，所以需要有辅助函数，来传递参数的变化</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ju</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> star,<span class="keyword">int</span> root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(star&gt;=root)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">int</span> i = root;</div><div class="line">        <span class="comment">//从后面开始找</span></div><div class="line">        <span class="keyword">while</span>(i&gt;star&amp;&amp;a[i-<span class="number">1</span>]&gt;a[root])</div><div class="line">            i--;<span class="comment">//找到比根小的坐标</span></div><div class="line">        <span class="comment">//从前面开始找 star到i-1应该比根小</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = star;j&lt;i-<span class="number">1</span>;j++)</div><div class="line">            <span class="keyword">if</span>(a[j]&gt;a[root])</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;;</div><div class="line">        <span class="keyword">return</span> ju(a,star,i-<span class="number">1</span>)&amp;&amp;ju(a, i, root-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>面试题34：二叉树中和为某一值的路径<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">//运用回溯思想</span></div><div class="line">    <span class="comment">//在整体的上面定义这两个变量，可以免去重新编写辅助函数的需要</span></div><div class="line">    ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</div><div class="line">        path.add(root.val);</div><div class="line">        target -= root.val;</div><div class="line">        <span class="comment">//剪枝函数</span></div><div class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>)&#123;</div><div class="line">             path.remove(path.size()-<span class="number">1</span>);</div><div class="line">             <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</div><div class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</div><div class="line">        &#125;</div><div class="line">        FindPath(root.left,target);</div><div class="line">        FindPath(root.right,target);</div><div class="line">        <span class="comment">//将最上面的一个去除</span></div><div class="line">        path.remove(path.size() - <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>面试题36：二叉搜索树与双向链表<br>解题思路：<br>1.将左子树构造成双链表，并返回链表头节点。<br>2.定位至左子树双链表最后一个节点。<br>3.如果左子树链表不为空的话，将当前root追加到左子树链表。<br>4.将右子树构造成双链表，并返回链表头节点。<br>5.如果右子树链表不为空的话，将该链表追加到root节点之后。<br>6.根据左子树链表是否为空确定返回的节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        <span class="comment">// 1.将左子树构造成双链表，并返回链表头节点</span></div><div class="line">        TreeNode left = Convert(root.left);</div><div class="line">        TreeNode p = left;</div><div class="line">        <span class="comment">// 2.定位至左子树双链表最后一个节点</span></div><div class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;p.right!=<span class="keyword">null</span>)&#123;</div><div class="line">            p = p.right;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 3.如果左子树链表不为空的话，将当前root追加到左子树链表</span></div><div class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span>)&#123;</div><div class="line">            p.right = root;</div><div class="line">            root.left = p;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 4.将右子树构造成双链表，并返回链表头节点</span></div><div class="line">        TreeNode right = Convert(root.right);</div><div class="line">        <span class="comment">// 5.如果右子树链表不为空的话，将该链表追加到root节点之后</span></div><div class="line">        <span class="keyword">if</span>(right!=<span class="keyword">null</span>)&#123;</div><div class="line">            right.left = root;</div><div class="line">            root.right = right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> left!=<span class="keyword">null</span>?left:root;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>面试题55：二叉树的深度<br>方法1：仿照面试题34<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        q.add(root);</div><div class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> n = q.size();</div><div class="line">            sum++;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</div><div class="line">                TreeNode temp = q.poll();</div><div class="line">                <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>) q.offer(temp.left);</div><div class="line">                <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>) q.offer(temp.right);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行时间为11ms</p><p>方法2：更简洁的使用递归的方法，树的深度 = 1 + 左子树深度及右子树深度中较深的深度，递归实现即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> nleft = TreeDepth(root.left);</div><div class="line">        <span class="keyword">int</span> nright = TreeDepth(root.right);</div><div class="line">        <span class="keyword">return</span> (nleft &gt; nright) ? (nleft + <span class="number">1</span>) : (nright + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行时间也是11ms</p><p>面试题28：对称的二叉树<br>分析：首先是根节点以及其左右子树，左子树的左子树与右子树的右子树相同，左子树的右子树与右子树的左子树相同，采用队规。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> comRoot(pRoot.left, pRoot.right);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">comRoot</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>) <span class="keyword">return</span> right==<span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> comRoot(left.right, right.left) &amp;&amp; comRoot(left.left, right.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>面试题8：二叉树的下一个节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function">TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode node)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;    <span class="comment">//如果有右子树，则找右子树的最左节点</span></div><div class="line">            node = node.right;</div><div class="line">            <span class="keyword">while</span>(node.left!=<span class="keyword">null</span>) node = node.left;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123; <span class="comment">//没右子树，则找第一个当前节点是父节点左孩子的节点</span></div><div class="line">            <span class="keyword">if</span>(node.next.left==node) <span class="keyword">return</span> node.next;</div><div class="line">            node = node.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;   <span class="comment">//退到了根节点仍没找到，则返回null</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>面试题：把二叉树打印成多行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">import</span> java.util.*;</div><div class="line"><span class="comment">//按层遍历，使用last和nlast来辅助换行</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; results;</div><div class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</div><div class="line"><span class="comment">//创建一个ArrayList&lt;ArrayList&lt;Integer&gt;&gt;用于存放答案</span></div><div class="line">results = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line"><span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> results;<span class="comment">//返回空的list</span></div><div class="line"><span class="keyword">this</span>.helper(pRoot);</div><div class="line"><span class="comment">//返回结果</span></div><div class="line"><span class="keyword">return</span> results;</div><div class="line"><span class="comment">//打印results中的元素，每打印一个就换行即可，不要纠结于必须得每个都加上换行符号</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line"><span class="comment">//创建一个队列</span></div><div class="line">LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="comment">//创建辅助变量last和nlast</span></div><div class="line">TreeNode last = root, nlast = <span class="keyword">null</span>;</div><div class="line">queue.add(root);</div><div class="line"><span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</div><div class="line">TreeNode temp = queue.poll();</div><div class="line">list.add(temp.val);</div><div class="line"><span class="comment">//压入左孩子并更新nlast</span></div><div class="line"><span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</div><div class="line">queue.add(temp.left);</div><div class="line">nlast = temp.left;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</div><div class="line">queue.add(temp.right);</div><div class="line">nlast = temp.right;</div><div class="line">&#125;</div><div class="line"><span class="comment">//如果弹出的temp==last证明这是一行的最后一个，此时的nlast所指即为下个last</span></div><div class="line"><span class="keyword">if</span>(temp == last)&#123;</div><div class="line">last = nlast;</div><div class="line">results.add(list);</div><div class="line"><span class="comment">//list再更新一次</span></div><div class="line">list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>面试题：按之字形顺序打印二叉树<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/91b69814117f4e8097390d107d2efbe0</span></div><div class="line">来源：牛客网</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</div><div class="line">        <span class="keyword">int</span> layer = <span class="number">1</span>;</div><div class="line">        <span class="comment">//s1存奇数层节点</span></div><div class="line">        Stack&lt;TreeNode&gt; s1 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">        s1.push(pRoot);</div><div class="line">        <span class="comment">//s2存偶数层节点</span></div><div class="line">        Stack&lt;TreeNode&gt; s2 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">         </div><div class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">         </div><div class="line">        <span class="keyword">while</span> (!s1.empty() || !s2.empty()) &#123;</div><div class="line">            <span class="keyword">if</span> (layer%<span class="number">2</span> != <span class="number">0</span>) &#123;</div><div class="line">                ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">                <span class="keyword">while</span> (!s1.empty()) &#123;</div><div class="line">                    TreeNode node = s1.pop();</div><div class="line">                    <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</div><div class="line">                        temp.add(node.val);</div><div class="line">                        System.out.print(node.val + <span class="string">" "</span>);</div><div class="line">                        s2.push(node.left);</div><div class="line">                        s2.push(node.right);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (!temp.isEmpty()) &#123;</div><div class="line">                    list.add(temp);</div><div class="line">                    layer++;</div><div class="line">                    System.out.println();</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">                <span class="keyword">while</span> (!s2.empty()) &#123;</div><div class="line">                    TreeNode node = s2.pop();</div><div class="line">                    <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</div><div class="line">                        temp.add(node.val);</div><div class="line">                        System.out.print(node.val + <span class="string">" "</span>);</div><div class="line">                        s1.push(node.right);</div><div class="line">                        s1.push(node.left);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (!temp.isEmpty()) &#123;</div><div class="line">                    list.add(temp);</div><div class="line">                    layer++;</div><div class="line">                    System.out.println();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>面试题：序列化二叉树<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</div><div class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            sb.append(<span class="string">"#,"</span>);</div><div class="line">            <span class="keyword">return</span> sb.toString();</div><div class="line">        &#125;</div><div class="line">        sb.append(root.val + <span class="string">","</span>);</div><div class="line">        sb.append(Serialize(root.left));</div><div class="line">        sb.append(Serialize(root.right));</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">  &#125;</div><div class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        index++;</div><div class="line">       <span class="keyword">int</span> len = str.length();</div><div class="line">        <span class="keyword">if</span>(index &gt;= len)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        String[] strr = str.split(<span class="string">","</span>);</div><div class="line">        TreeNode node = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(!strr[index].equals(<span class="string">"#"</span>))&#123;</div><div class="line">            node = <span class="keyword">new</span> TreeNode(Integer.valueOf(strr[index]));</div><div class="line">            node.left = Deserialize(str);</div><div class="line">            node.right = Deserialize(str);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>面试题：二叉搜索树的第k个节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//思路：二叉搜索树按照中序遍历的顺序打印出来正好就是排序好的顺序。</span></div><div class="line"><span class="comment">//     所以，按照中序遍历顺序找到第k个结点就是结果。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">//计数器</span></div><div class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123; <span class="comment">//中序遍历寻找第k个</span></div><div class="line">            TreeNode node = KthNode(root.left,k);</div><div class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            index ++;</div><div class="line">            <span class="keyword">if</span>(index == k)</div><div class="line">                <span class="keyword">return</span> root;</div><div class="line">            node = KthNode(root.right,k);</div><div class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>面试题：滑动窗口的最大值<br>滑动窗口题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution14</span></span>&#123;</div><div class="line"><span class="comment">//num表示原始数组，size表示窗口的大小</span></div><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> size)</span></span>&#123;</div><div class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> res;</div><div class="line">        <span class="comment">//双端队列</span></div><div class="line">        ArrayDeque&lt;Integer&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>; <span class="comment">//用begin来维持一个窗口的大小size</span></div><div class="line">        <span class="comment">//遍历数组</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)&#123;</div><div class="line">        begin = i - size + <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(q.isEmpty()) q.add(i);<span class="comment">//为空时直接添加</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(begin &gt; q.peekFirst()) q.pollFirst(); <span class="comment">//不为空时当最前面的下标过期时，先将该下标丢掉。</span></div><div class="line">            <span class="comment">//添加下标到队尾的逻辑,</span></div><div class="line">            <span class="keyword">while</span>(!q,isEmpty() &amp;&amp; num[q.peekLast()] &lt;= num[i])</div><div class="line">            q.pollLast();<span class="comment">//把比num[i]小的丢掉</span></div><div class="line">            q.add[i];<span class="comment">//把i加上</span></div><div class="line">            <span class="keyword">if</span>(begin &gt;= <span class="number">0</span>) res.add(num[q.peekFirst()]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#####树&lt;br&gt;面试题7：重建二叉树&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/d
      
    
    </summary>
    
      <category term="学习" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="编程" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="剑指offer" scheme="http://writinglife.vip/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>回溯法面试题</title>
    <link href="http://writinglife.vip/2018/05/02/%E5%89%91%E6%8C%87-%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <id>http://writinglife.vip/2018/05/02/剑指-回溯法/</id>
    <published>2018-05-02T05:13:26.000Z</published>
    <updated>2018-05-03T14:34:26.622Z</updated>
    
    <content type="html"><![CDATA[<p>###剑指offer题目分类</p><p>#####七、回溯法<br>介绍：<a href="https://blog.csdn.net/qfikh/article/details/51960331" target="_blank" rel="external">https://blog.csdn.net/qfikh/article/details/51960331</a><br>重点：1、回溯法 = 穷举 + 剪枝；<br>&emsp;&emsp;&emsp;2、回溯法依赖的两种数据结构：子集树和排列数，时间复杂度分别为O(2^n)和O(n!).n为元素个数<br>&emsp;&emsp;&emsp;3、回溯法的两种算法框架：递归回溯和迭代回溯<br>面试题12：矩阵中的路径<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length];</div><div class="line">        <span class="comment">//此为穷举</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)&#123;</div><div class="line">                <span class="comment">//判断该节点是否可以作为起点</span></div><div class="line">                <span class="keyword">if</span>(helper(matrix, rows, cols, i, j, str, <span class="number">0</span>, flag))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//遍历完仍旧没有一条符合</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//helper函数用来判断整条路径，注意这里对边界点的处理</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j,<span class="keyword">char</span>[] str, <span class="keyword">int</span> pathlength, <span class="keyword">boolean</span>[] flag)</span></span>&#123;</div><div class="line">        <span class="comment">//pathlength为此时遍历的路径的深度，flag是为了表示该点是否已经被遍历过</span></div><div class="line">        <span class="comment">//还未到达递归出口时，比较matrix[i][j]与str[pathlength]的关系，注意这里的matrix是一维的</span></div><div class="line">        <span class="keyword">int</span> index = i*cols + j;</div><div class="line">        <span class="comment">//此为剪枝函数，只要该节点不满足下面的，都不继续遍历</span></div><div class="line">        <span class="comment">//注意处理边界条件的方式</span></div><div class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=rows || j&lt;<span class="number">0</span> || j&gt;=cols || flag[index]==<span class="keyword">true</span> || matrix[index] != str[pathlength])</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//满足则继续向后遍历，此时开始在pathlength节点上进行扩展,并将该节点的标识置为true</span></div><div class="line">        flag[index] = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">//递归出口，pathlength等于str的长度-1</span></div><div class="line">        <span class="keyword">if</span>(pathlength == str.length - <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        pathlength++;</div><div class="line">        <span class="keyword">if</span>(helper(matrix, rows, cols, i-<span class="number">1</span>, j, str, pathlength, flag) || helper(matrix, rows, cols, i+<span class="number">1</span>, j, str, pathlength, flag) ||</div><div class="line">          helper(matrix, rows, cols, i, j+<span class="number">1</span>, str, pathlength, flag) || helper(matrix, rows, cols, i, j-<span class="number">1</span>, str, pathlength, flag))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="comment">//如果上面if中没有返回true，则说明这层节点不行</span></div><div class="line">        flag[index] = <span class="keyword">false</span>;</div><div class="line">        pathlength--;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注释写的比较清楚，从代码中去寻找开头所说的几个重点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">//特殊输入</span></div><div class="line">        <span class="keyword">if</span>(threshold &lt; <span class="number">0</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows * cols];</div><div class="line">        <span class="comment">//与上题不一样的地方是，这里的起点是固定的，不用对起点穷举</span></div><div class="line">        count = helper(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, flag);</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[] flag)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="comment">//剪枝函数</span></div><div class="line">        <span class="keyword">if</span>(check(threshold, rows, cols, i, j, flag))&#123;</div><div class="line">            <span class="comment">//表示该点符合条件，计算该点的其他点是否符合,flag标志位变</span></div><div class="line">            flag[i*cols + j] = <span class="keyword">true</span>;</div><div class="line">            <span class="comment">//上下左右穷举</span></div><div class="line">            count = <span class="number">1</span> + helper(threshold, rows, cols, i+<span class="number">1</span>, j, flag) + helper(threshold, rows, cols, i-<span class="number">1</span>, j, flag)</div><div class="line">                      +helper(threshold, rows, cols, i, j+<span class="number">1</span>, flag) + helper(threshold, rows, cols, i, j-<span class="number">1</span>, flag);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//check函数用来检查剪枝条件</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[] flag)</span></span>&#123;</div><div class="line">        <span class="comment">//加入对于边界条件的处理</span></div><div class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp; i&lt;rows &amp;&amp; j&lt;cols &amp;&amp; getDigitSum(i) + getDigitSum(j) &lt;= threshold &amp;&amp; !flag[i*cols + j])</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//getDigitSum用来得到数位和</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</div><div class="line">            sum += num % <span class="number">10</span>;</div><div class="line">            num /= <span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###剑指offer题目分类&lt;/p&gt;
&lt;p&gt;#####七、回溯法&lt;br&gt;介绍：&lt;a href=&quot;https://blog.csdn.net/qfikh/article/details/51960331&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http
      
    
    </summary>
    
      <category term="学习" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="编程" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="剑指offer" scheme="http://writinglife.vip/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>链表面试题</title>
    <link href="http://writinglife.vip/2018/05/01/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8/"/>
    <id>http://writinglife.vip/2018/05/01/剑指offer-链表/</id>
    <published>2018-05-01T05:13:26.000Z</published>
    <updated>2018-05-03T14:33:10.597Z</updated>
    
    <content type="html"><![CDATA[<p>###剑指offer题目分类</p><p>#####2、链表<br>面试题6：从尾到头打印链表<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(listNode == <span class="keyword">null</span>) <span class="keyword">return</span> res;</div><div class="line">        printListFromTailToHead(listNode.next);</div><div class="line">        res.add(listNode.val);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>面试题22：链表中倒数第k个节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="comment">//利用链表本身的遍历进行计数：</span></div><div class="line">    <span class="comment">//先遍历进行k-1次，到达第k个结点，然后一个从k开始遍历，另一个从头结点开始遍历，</span></div><div class="line">    <span class="comment">//返回当第一个遍历结束时，第二个所在的位置，即为倒数第k个结点</span></div><div class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        ListNode pre = head, last = head;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(pre.next != <span class="keyword">null</span>) pre = pre.next;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(pre.next != <span class="keyword">null</span>)&#123;</div><div class="line">            pre = pre.next;</div><div class="line">            last = last.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> last;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>面试题24：反转链表<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###剑指offer题目分类&lt;/p&gt;
&lt;p&gt;#####2、链表&lt;br&gt;面试题6：从尾到头打印链表&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1
      
    
    </summary>
    
      <category term="学习" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="编程" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="剑指offer" scheme="http://writinglife.vip/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="http://writinglife.vip/2018/03/03/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://writinglife.vip/2018/03/03/从尾到头打印链表/</id>
    <published>2018-03-03T07:03:26.000Z</published>
    <updated>2018-03-03T07:11:10.089Z</updated>
    
    <content type="html"><![CDATA[<h3 id="剑指—从尾到头打印链表"><a href="#剑指—从尾到头打印链表" class="headerlink" title="剑指—从尾到头打印链表"></a>剑指—从尾到头打印链表</h3><h4 id="emsp-1-题目描述"><a href="#emsp-1-题目描述" class="headerlink" title="&emsp;1. 题目描述"></a>&emsp;1. 题目描述</h4><p>&emsp;&emsp;输入一个链表，从尾到头打印链表每个节点的值。<br><a id="more"></a></p><h4 id="emsp-2-分析"><a href="#emsp-2-分析" class="headerlink" title="&emsp;2. 分析"></a>&emsp;2. 分析</h4><p>&emsp;&emsp;<font color="red">思路一</font>：很容易想到利用栈，先遍历一遍链表存入栈中，再遍历一遍栈，存入ArrayList输出。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">*    public class ListNode &#123;</span></div><div class="line"><span class="comment">*        int val;</span></div><div class="line"><span class="comment">*        ListNode next = null;</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">*        ListNode(int val) &#123;</span></div><div class="line"><span class="comment">*            this.val = val;</span></div><div class="line"><span class="comment">*        &#125;</span></div><div class="line"><span class="comment">*    &#125;</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">if</span>(listNode == <span class="keyword">null</span>) <span class="keyword">return</span> res;</div><div class="line">        Stack &lt;Integer&gt; sk = <span class="keyword">new</span> Stack &lt;Integer&gt;();</div><div class="line">        sk.push(listNode.val);</div><div class="line">        <span class="keyword">while</span>(listNode.next != <span class="keyword">null</span>)&#123;</div><div class="line">            ListNode Node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">            Node = listNode.next;</div><div class="line">            sk.push(Node.val);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(!sk.empty())</div><div class="line">            res.add(sk.pop());</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行时间23ms，占用内存8764K</p><p>&emsp;&emsp;<font color="red">思路二</font>：查看书籍，建议用递归的方法，可降低时间复杂度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">helper(res, listNode); <span class="keyword">return</span> res; &#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(ArrayList&lt;Integer&gt; res, ListNode head)</span></span>&#123;</div><div class="line"><span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="keyword">if</span> (head.next != <span class="keyword">null</span>) &#123;</div><div class="line"> helper(res, head.next);</div><div class="line">                &#125;</div><div class="line">res.add(head.val);</div><div class="line">        &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;剑指—从尾到头打印链表&quot;&gt;&lt;a href=&quot;#剑指—从尾到头打印链表&quot; class=&quot;headerlink&quot; title=&quot;剑指—从尾到头打印链表&quot;&gt;&lt;/a&gt;剑指—从尾到头打印链表&lt;/h3&gt;&lt;h4 id=&quot;emsp-1-题目描述&quot;&gt;&lt;a href=&quot;#emsp-1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;&amp;emsp;1. 题目描述&quot;&gt;&lt;/a&gt;&amp;emsp;1. 题目描述&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;输入一个链表，从尾到头打印链表每个节点的值。&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="编程" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="剑指offer" scheme="http://writinglife.vip/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>替换空格</title>
    <link href="http://writinglife.vip/2018/03/03/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://writinglife.vip/2018/03/03/替换空格/</id>
    <published>2018-03-03T06:22:26.000Z</published>
    <updated>2018-03-03T07:11:46.426Z</updated>
    
    <content type="html"><![CDATA[<h3 id="剑指—替换空格"><a href="#剑指—替换空格" class="headerlink" title="剑指—替换空格"></a>剑指—替换空格</h3><h4 id="emsp-1-题目描述"><a href="#emsp-1-题目描述" class="headerlink" title="&emsp;1. 题目描述"></a>&emsp;1. 题目描述</h4><p>&emsp;&emsp;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br><a id="more"></a></p><h4 id="emsp-2-分析"><a href="#emsp-2-分析" class="headerlink" title="&emsp;2. 分析"></a>&emsp;2. 分析</h4><p>&emsp;&emsp;<font color="red">思路一</font>：创建新的字符串并在新的字符串上进行替换<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</div><div class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</div><div class="line">        String reString = <span class="string">"%20"</span>;</div><div class="line">        <span class="keyword">int</span> length = str.length();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(str.charAt(i)== <span class="string">' '</span>) res.append(reString);</div><div class="line">            <span class="keyword">else</span> res.append(str.charAt(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&emsp;&emsp;<font color="red">思路二</font>：在原来的字符串上进行替换<br>&emsp;&emsp;首先遍历得到空格数，以此计算需要将字符串扩展的长度；然后由后往前遍历，分遇到空格和非空格两种情况。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</div><div class="line">        <span class="comment">//遍历一遍str，找出空格的数目</span></div><div class="line">        <span class="keyword">int</span> length = str.length();</div><div class="line">        <span class="keyword">int</span> numSpace = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</div><div class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>) numSpace++;</div><div class="line">        <span class="keyword">int</span> newLength = length + numSpace*<span class="number">2</span>;</div><div class="line">        <span class="comment">//由后往前遍历</span></div><div class="line">        str.setLength(newLength);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p1 = length - <span class="number">1</span>,p2 = newLength - <span class="number">1</span>; p1 &gt; -<span class="number">1</span>; p1--)&#123;</div><div class="line">            <span class="keyword">if</span>(str.charAt(p1) != <span class="string">' '</span>) &#123;</div><div class="line">                str.setCharAt(p2,str.charAt(p1));</div><div class="line">                p2--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                str.setCharAt(p2,<span class="string">'0'</span>);</div><div class="line">                p2--;</div><div class="line">                str.setCharAt(p2,<span class="string">'2'</span>);</div><div class="line">                p2--;</div><div class="line">                str.setCharAt(p2,<span class="string">'%'</span>);</div><div class="line">                p2--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> str.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;剑指—替换空格&quot;&gt;&lt;a href=&quot;#剑指—替换空格&quot; class=&quot;headerlink&quot; title=&quot;剑指—替换空格&quot;&gt;&lt;/a&gt;剑指—替换空格&lt;/h3&gt;&lt;h4 id=&quot;emsp-1-题目描述&quot;&gt;&lt;a href=&quot;#emsp-1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;&amp;emsp;1. 题目描述&quot;&gt;&lt;/a&gt;&amp;emsp;1. 题目描述&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="编程" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="剑指offer" scheme="http://writinglife.vip/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="http://writinglife.vip/2018/03/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://writinglife.vip/2018/03/03/二维数组的查找/</id>
    <published>2018-03-03T05:13:26.000Z</published>
    <updated>2018-03-03T06:48:43.246Z</updated>
    
    <content type="html"><![CDATA[<h3 id="剑指—二维数组中的查找"><a href="#剑指—二维数组中的查找" class="headerlink" title="剑指—二维数组中的查找"></a>剑指—二维数组中的查找</h3><h4 id="emsp-1-题目描述"><a href="#emsp-1-题目描述" class="headerlink" title="&emsp;1. 题目描述"></a>&emsp;1. 题目描述</h4><p>&emsp;&emsp;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数.<br><a id="more"></a></p><h4 id="emsp-2-分析"><a href="#emsp-2-分析" class="headerlink" title="&emsp;2. 分析"></a>&emsp;2. 分析</h4><p>&emsp;&emsp;正常的思路是，将二维数组画成一个矩形，然后在矩形中选取一个数字，分三种情况（等于、大于、小于）来分析查找的过程，继续分析下去会发现情况开始变得很复杂了，因为，要查找的数字相对于选取的位置可能在两个区域出现，而且这两个区域还有所重叠。<br><br>&emsp;&emsp;<font color="orange">遇到这种难题时，不妨从一个具体的例子入手，能更直观的找到规律。</font><br><br>&emsp;&emsp;前面的方法是在矩形中间选取一个数，这次我们想的是从<font color="red">矩形的角</font>选取，分别有四种选取方案：左上、左下，右上、右下。经分析可知，当选择左下和右上的方案时该问题得到很大简化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> row = array.length;</div><div class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span> col = array[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="keyword">int</span> j = col-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; row &amp;&amp; j &gt; -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(target == array[i][j]) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[i][j]) j--;</div><div class="line">            <span class="keyword">else</span> i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;剑指—二维数组中的查找&quot;&gt;&lt;a href=&quot;#剑指—二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;剑指—二维数组中的查找&quot;&gt;&lt;/a&gt;剑指—二维数组中的查找&lt;/h3&gt;&lt;h4 id=&quot;emsp-1-题目描述&quot;&gt;&lt;a href=&quot;#emsp-1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;&amp;emsp;1. 题目描述&quot;&gt;&lt;/a&gt;&amp;emsp;1. 题目描述&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数.&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="编程" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="剑指offer" scheme="http://writinglife.vip/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>2017总结 / 2018目标</title>
    <link href="http://writinglife.vip/2018/01/02/2018%E4%BC%9A%E6%98%AF%E4%B8%8D%E5%B9%B3%E5%87%A1%E7%9A%84%E4%B8%80%E5%B9%B4/"/>
    <id>http://writinglife.vip/2018/01/02/2018会是不平凡的一年/</id>
    <published>2018-01-02T12:20:26.000Z</published>
    <updated>2018-01-02T12:20:46.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2017总结-2018目标"><a href="#2017总结-2018目标" class="headerlink" title="2017总结 / 2018目标"></a>2017总结 / 2018目标</h2><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>&emsp;不经意间，又是一年。<br>&emsp;2017，这个以后只能用作回忆的数字。<br>&emsp;细数自己的2017，很惭愧，没有任何可圈可点的成就，没有参加大比赛，没有实习，没有发表很好的论文。<br>&emsp;即使这样，但还是需要细细想想自己一年来做了什么吧，如果不能直面生活，生活就可能永远会背对着我了。</p><a id="more"></a><h3 id="2017总结"><a href="#2017总结" class="headerlink" title="2017总结"></a>2017总结</h3><h4 id="emsp-做到的："><a href="#emsp-做到的：" class="headerlink" title="&emsp;做到的："></a>&emsp;做到的：</h4><p>&emsp;1、    完成了研一的课程，修满了所需要的学分，依靠研一的成绩拿到了一等奖学金；<br>&emsp;2、    完成一篇小论文，目前已经收到收录的通知<br>&emsp;3、    JAVA学习中，并开始橙色算法书的学习已经线上课程的学习，目前已完成第二周；<br>&emsp;4、    看了大约5本课外书，现在在看自卑与超越；<br>&emsp;5、    两次旅行，一次哈尔滨，一次天津；<br>&emsp;6、    一场失败的恋爱。</p><h4 id="emsp-未做到的："><a href="#emsp-未做到的：" class="headerlink" title="&emsp;未做到的："></a>&emsp;未做到的：</h4><p>1、    健身增肌；<br>2、    参加一个技术性比赛；<br>3、    国家奖学金；<br>4、    LeetCode；</p><h3 id="2018计划"><a href="#2018计划" class="headerlink" title="2018计划"></a>2018计划</h3><p>1、    找到一份好工作；<br>2、    再发表一篇小论文；<br>3、    参加一个技术性比赛并获奖；<br>4、    让爸妈知道我爱他们；<br>5、    带妹妹出去旅行一次；<br>6、    阅读24本书；<br>7、    刷完LeetCode；<br>8、    看一场演唱会；<br>9、    遇到她</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2017总结-2018目标&quot;&gt;&lt;a href=&quot;#2017总结-2018目标&quot; class=&quot;headerlink&quot; title=&quot;2017总结 / 2018目标&quot;&gt;&lt;/a&gt;2017总结 / 2018目标&lt;/h2&gt;&lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;&amp;emsp;不经意间，又是一年。&lt;br&gt;&amp;emsp;2017，这个以后只能用作回忆的数字。&lt;br&gt;&amp;emsp;细数自己的2017，很惭愧，没有任何可圈可点的成就，没有参加大比赛，没有实习，没有发表很好的论文。&lt;br&gt;&amp;emsp;即使这样，但还是需要细细想想自己一年来做了什么吧，如果不能直面生活，生活就可能永远会背对着我了。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://writinglife.vip/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="年终总结" scheme="http://writinglife.vip/categories/%E7%94%9F%E6%B4%BB/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="生活" scheme="http://writinglife.vip/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="年终总结" scheme="http://writinglife.vip/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Coursera普林斯顿大学算法公开课</title>
    <link href="http://writinglife.vip/2017/12/12/Coursera%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%80%E5%91%A8%E4%BD%9C%E4%B8%9A/"/>
    <id>http://writinglife.vip/2017/12/12/Coursera算法第一周作业/</id>
    <published>2017-12-12T13:38:26.000Z</published>
    <updated>2017-12-13T05:43:13.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一周作业："><a href="#第一周作业：" class="headerlink" title="第一周作业："></a>第一周作业：</h2><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>&emsp;文章为自己的学习笔记，仅作自己复习用<br><a id="more"></a></p><h4 id="emsp-1-题目描述"><a href="#emsp-1-题目描述" class="headerlink" title="&emsp;1. 题目描述"></a>&emsp;1. 题目描述</h4><p> 在Coursera上的视频教程中的最后，提到了”Percolation”问题，同时教授也给出了“vitual box”的思路。<br>&emsp;&emsp;<a href="http://coursera.cs.princeton.edu/algs4/assignments/percolation.html" target="_blank" rel="external">具体描述点此查看</a><br>注意以下几点（题中所给的提示）：<br>1、除了引入随机库和输入输出库还引入了“WeightedQuickUnionUF”，这实际上提示了我们可以采用此方法的思路来解决此问题。<br>2、目的是得到一个阈值和置信区间（计算公式也给出了）<br>3、题目给出了需要写的两个java文件以及它们的API，根据API完成业务逻辑即可。<br>以上读完题之后应该能提取到的主要要点。</p><h4 id="emsp-2-构思"><a href="#emsp-2-构思" class="headerlink" title="&emsp;2. 构思"></a>&emsp;2. 构思</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Percolation &#123;</div><div class="line">public Percolation(int n) // create n-by-n grid, with all sites blocked</div><div class="line">public void open(int row, int col) // open site (row, col) if it is not open already</div><div class="line">public boolean isOpen(int row, int col) // is site (row, col) open?</div><div class="line">public boolean isFull(int row, int col) // is site (row, col) full?</div><div class="line">public int numberOfOpenSites() // number of open sites</div><div class="line">public boolean percolates() // does the system percolate?</div><div class="line"></div><div class="line">public static void main(String[] args) // test client (optional)&#125;</div></pre></td></tr></table></figure><p><strong>public Percolation(int n)</strong>：构造函数，输入一个n，需要表示出n^2个方格。联系“<em>WeightedQuickUnionUF</em>”，不难想到，给每一个方格标上数字进行表示即可。同时考虑到“<em>vitural box</em>”，所以应该共有“n^2 + 2”个方格。每个方格的状态也应该被初始化，最开始的状态都是关闭的，这里要注意的是，虚拟方格的状态不需要被初始化，因为只要第一行或者最后一行有一个被打开，它们就会与虚拟窗格相连。用“state[n^2]”表示所以格子的状态。<br><strong>public void open(int row, int col)</strong>：打开一个方格，首先判断此方格是否已经打开，处于关闭时将需要进行一系列的操作：1.此格子状态置为打开；2.判断其相邻的格子是否打开，打开则连接；3.注意数组state与n<em>n方格以及与整个加上vitual box之间的对应（手绘图对应）<br><strong>public boolean isOpen(int row, int col)</strong>：判断某个格子是否是开的，返回state中对应的值即可。<br><strong>public boolean isFull(int row, int col)</strong>：首先明确Fullsite的定义是，此窗格与顶部的窗格相连（即与虚拟格子0相连），这个函数隐藏了一个“回流问题”<br><strong>public int numberOfOpenSites()</strong>：返回打开的格子的数量用于最后计算阈值<br><em>*public boolean percolates()</em></em>：判断系统是否连通<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class PercolationStats &#123; </div><div class="line"> public PercolationStats(int n, int trials) // perform trials independent experiments on an n-by-n grid </div><div class="line"> public double mean() // sample mean of percolation threshold </div><div class="line"> public double stddev() // sample standard deviation of percolation threshold </div><div class="line"> public double confidenceLo() // low endpoint of 95% confidence interval </div><div class="line"> public double confidenceHi() // high endpoint of 95% confidence interval</div><div class="line"></div><div class="line">public static void main(String[] args) // test client (described below)&#125;</div></pre></td></tr></table></figure></p><p><strong>public PercolationStats(int n, int trials)</strong>：构造函数，进行trials次的n<em>n的蒙特卡洛实验，每次实验如果系统一旦连通则终止，返回此时打开的格子数并计算相关参数<br><em>*public static void main(String[] args)：</em></em><br>编程实现过程中遇到的问题：<br>1、open(int row, int col)函数中，与相邻格子进行连接时要先判断相邻格子是否处于打开状态，而在判断此之前，应该小心特殊行和特殊列可能会出现溢出的问题。<br>2、方格模型，依据方格的行列计算出的值和保存格子状态的state数组之间的对应关系不能搞混。如下图：</p><p>3、解决“回流问题”。如图为回流问题，可能导致本没有连通的系统连通了。</p><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/c11.jpg" width="400" height="300"><br></div><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/c22.jpg" width="400" height="300"><br></div><p>此时isFull()函数派上用场了，percolates函数只用来判断系统连通与否，而isFull函数用来判断是否有格子已经和顶部的虚拟格子0相连，使用连个UF对象，一个使用底部虚拟格子，一个不用，判断连通用前者，判断full用后者。 实际上不需要isFull函数也能完成这个判断连通的功能，题目设置这个isFull是为了让我们注意到“回流”问题。<br>4、samples[i] = a / val;中samples为double类型，a与val必须有一个为double，若两者均为int,结果为int。</p><p>完整代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import edu.princeton.cs.algs4.WeightedQuickUnionUF;</div><div class="line"></div><div class="line">public class Percolation &#123;</div><div class="line">private final int val;</div><div class="line">private final int nval; // 将n传递出来</div><div class="line">private boolean[] state; // 窗格的状态</div><div class="line">private int openSites; // 开房窗格的数量，用于最后的计算</div><div class="line">private final WeightedQuickUnionUF uf;</div><div class="line">private final WeightedQuickUnionUF uf_back;</div><div class="line"></div><div class="line">public Percolation(int n) &#123; // 初始化n*n网格</div><div class="line">if (n &lt; 1)</div><div class="line">throw new IllegalArgumentException();</div><div class="line">nval = n;</div><div class="line">val = n * n;</div><div class="line">uf = new WeightedQuickUnionUF(val + 2);</div><div class="line">uf_back = new WeightedQuickUnionUF(val + 2);</div><div class="line">openSites = 0;</div><div class="line">state = new boolean[val]; // ！！！只保存窗格的状态，虚拟节点的状态不能保存</div><div class="line">for (int i = 0; i &lt; state.length; i++)</div><div class="line">state[i] = false;  // 初始化所有窗格为闭</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void open(int row, int col) &#123; // 打开网格(row,col)，如果此时状态为关闭</div><div class="line">InException(row, col);</div><div class="line">int temp = (row - 1) * nval + col;</div><div class="line">if (!state[temp - 1]) &#123;</div><div class="line">state[temp - 1] = true;</div><div class="line">openSites++;</div><div class="line">if (row == 1) &#123; // 若是在第一行，与虚拟顶部相连</div><div class="line">uf.union(temp, 0);</div><div class="line">uf_back.union(temp, 0);</div><div class="line">&#125;</div><div class="line">// 若是在最后一行，与虚拟底部相连，但是注意只连uf</div><div class="line">if (row == nval)</div><div class="line">uf.union(temp, val + 1);</div><div class="line">// 第一列和第N列应该单独拿出来</div><div class="line">if (col &gt; 1 &amp;&amp; state[temp - 2]) &#123;</div><div class="line">uf.union(temp, temp - 1);</div><div class="line">uf_back.union(temp, temp - 1);</div><div class="line">&#125;</div><div class="line">if (col &lt; nval &amp;&amp; state[temp]) &#123;</div><div class="line">uf.union(temp, temp + 1);</div><div class="line">uf_back.union(temp, temp + 1);</div><div class="line">&#125;</div><div class="line">if (row &gt; 1 &amp;&amp; state[temp - nval - 1]) &#123;</div><div class="line">uf.union(temp, temp - nval);</div><div class="line">uf_back.union(temp, temp - nval);</div><div class="line">&#125;</div><div class="line">if (row &lt; nval &amp;&amp; state[temp + nval - 1]) &#123;</div><div class="line">uf.union(temp, temp + nval);</div><div class="line">uf_back.union(temp, temp + nval);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 打开网格的同时，应该检查其上下左右是否有开放窗格，有的话则进行连接</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean isOpen(int row, int col) &#123; // 判断网格(row,col)的状态</div><div class="line">InException(row, col);</div><div class="line">int temp = (row - 1) * nval + col;</div><div class="line">return state[temp - 1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean isFull(int row, int col) &#123;</div><div class="line">InException(row, col);</div><div class="line">int temp = (row - 1) * nval + col ; //此处的temp与前面的temp不一样，前面的temp是state的下标，此处是窗格</div><div class="line">// Fullsite的定义：此窗格与顶部的窗格相连</div><div class="line">// 所以一个系统连通的条件是底部那一行是否存在Fullsite</div><div class="line">return (uf_back.connected(temp,0) &amp;&amp; state[temp-1]); //</div><div class="line">&#125;</div><div class="line"></div><div class="line">public int numberOfOpenSites() &#123; // 返回开放窗格的数量</div><div class="line">return openSites;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean percolates() &#123; // 判断系统是否连通</div><div class="line">return uf.connected(0, val + 1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void InException(int row, int col) &#123;</div><div class="line">if (row &lt; 1 || row &gt; nval || col &lt; 1 || col &gt; nval)</div><div class="line">throw new IllegalArgumentException();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import edu.princeton.cs.algs4.StdOut;</div><div class="line">import edu.princeton.cs.algs4.StdRandom;</div><div class="line">import edu.princeton.cs.algs4.StdStats;</div><div class="line"></div><div class="line">public class PercolationStats &#123;</div><div class="line">private double mean;</div><div class="line">private double std;</div><div class="line">private double halfInterval;</div><div class="line"></div><div class="line">public PercolationStats(int n, int trials) &#123; // 在n*n的系统中试验trials次</div><div class="line">if (n &lt; 1 || trials &lt; 1)</div><div class="line">throw new IllegalArgumentException();</div><div class="line"></div><div class="line">double val = n * n; // 必须用double，否则后面的samples结果将为整型</div><div class="line">double[] samples = new double[trials];</div><div class="line">for (int i = 0; i &lt; trials; i++) &#123;</div><div class="line">Percolation percolation = new Percolation(n);</div><div class="line">while (!percolation.percolates()) &#123;</div><div class="line">int row = StdRandom.uniform(n) + 1; // StdRandom.uniform(n)返回[0,n)的整数</div><div class="line">int col = StdRandom.uniform(n) + 1;</div><div class="line">percolation.open(row, col);</div><div class="line">&#125;</div><div class="line">int a = percolation.numberOfOpenSites();</div><div class="line">samples[i] = a / val;</div><div class="line"></div><div class="line">&#125;</div><div class="line">mean = StdStats.mean(samples);</div><div class="line">std = StdStats.stddev(samples);</div><div class="line">halfInterval = 1.96 * std / java.lang.Math.sqrt(trials);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public double mean() &#123; // 连通阈值的采样均值</div><div class="line">return mean;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public double stddev() &#123; // 连通阈值的采样标准差</div><div class="line">return std;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public double confidenceLo() &#123; //</div><div class="line">return mean - halfInterval;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public double confidenceHi() &#123; //</div><div class="line">return mean + halfInterval;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">// TODO Auto-generated method stub</div><div class="line">     int n = Integer.parseInt(args[0]);</div><div class="line">int trials = Integer.parseInt(args[1]);</div><div class="line">PercolationStats percolationStats = new PercolationStats(n, trials);</div><div class="line">double mean = percolationStats.mean();</div><div class="line">double std = percolationStats.stddev();</div><div class="line">double confidenceLo = percolationStats.confidenceLo();</div><div class="line">double confidenceHi = percolationStats.confidenceHi();</div><div class="line">StdOut.printf(&quot;mean%20s= %f\n&quot;, &quot; &quot;, mean);</div><div class="line">StdOut.printf(&quot;stddev%18s= %f\n&quot;, &quot; &quot;, std);</div><div class="line">StdOut.printf(&quot;95%% confidence interval = [%f, %f]&quot;, confidenceLo, confidenceHi);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一周作业：&quot;&gt;&lt;a href=&quot;#第一周作业：&quot; class=&quot;headerlink&quot; title=&quot;第一周作业：&quot;&gt;&lt;/a&gt;第一周作业：&lt;/h2&gt;&lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;&amp;emsp;文章为自己的学习笔记，仅作自己复习用&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Coursera" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/Coursera/"/>
    
    
      <category term="Algorithm" scheme="http://writinglife.vip/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>壁花少年（二）</title>
    <link href="http://writinglife.vip/2017/09/13/wallflower02-0/"/>
    <id>http://writinglife.vip/2017/09/13/wallflower02-0/</id>
    <published>2017-09-13T15:38:24.000Z</published>
    <updated>2017-09-13T15:38:37.380Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<a href="http://pan.baidu.com/s/1c1OKADa" target="_blank" rel="external">点此下载英文原著pdf版</a></p><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/%E5%B0%81%E9%9D%A2.jpg" width="306" height="213"><br></div><a id="more"></a><h2 id="壁花少年（二）"><a href="#壁花少年（二）" class="headerlink" title="壁花少年（二）"></a>壁花少年（二）</h2><p>&emsp;&emsp;1991.9.7<br>&emsp;&emsp;亲爱的朋友：<br>&emsp;&emsp;我不喜欢高中。食堂被称作“营养中心”，这很奇怪。在我上的高级英语班上有一个女孩叫Susan。中学的时候，Susan很喜欢和周围人开玩笑找乐子。她喜欢看点用，她的哥哥Frank会帮她把她喜欢的歌做成磁带，然后她会与我们分享这些美妙的音乐。但夏天过去后，她脱掉了背带，长得更高更漂亮，胸也变大了。现在的她，在走廊上时表现得寡言矜持，尤其是当男孩们在周围时。这使我感到伤感，因为Susan看起来并不开心。说实话，她不爱承认自己是高级英语班的，而且她也不再喜欢像以前一样在走廊遇见时跟我打招呼了。<br>&emsp;&emsp;当Susan在关于Michael的心理指导会上时，她说，Michael曾告诉她，她是这个世界上最美丽的女孩。然后，他让自己“跟他走”，这在任何一所学校都是很大的事。在高中，这被称作是“交往”。他们接吻了，也在一起谈论电影。而她现在特别想念他，因为Michael是她最好的朋友。<br>&emsp;&emsp;这也很有趣，因为在我们学校，正常情况下，男孩和女孩不会成为最好的朋友。但Michael和Susan例外。这有点像“我”和Helen阿姨。对不起，我应该说“我和Helen阿姨”，这是我这周学到的一个知识点。这是更一致的规则。（此处写的是Chalie把英语中”I”和”me”搞错了）<br>&emsp;&emsp;大多数时间里我都保持安静，看起来似乎只有一个名叫Sean的小孩真正注意到了我。他在体育课结束之后等着我，然后说了非常不成熟的话，比如他将如何把我“旋转”，意思是在厕所抓住我的头让它不动，然后迅速让我旋转，使头发打转。我对他说了同样的话，他看起来也非常的不开心。接着他就发疯似开始打我，而我只是做了我哥哥教我做的事情。我哥哥是个打架的好手。<br>&emsp;&emsp;“冲着膝盖、喉咙还有眼睛去打。”<br>&emsp;&emsp;我这样做了，并且我真的弄伤了Sean。然后我开始哭。后来我的姐姐只得离开她高年级的荣誉班，开车把我带回了家。我被叫到Small老师的办公室，但是我并没有被休学或受到其他处分，因为有一个孩子告诉了Small老师这次打架的真相。<br>&emsp;&emsp;“是Sean先动手的，他只是自我防卫。”<br>&emsp;&emsp;而事实确实是这样。我只是不知道为什么Sean想要打我。我对他没有做任何不好的事。我很瘦小，这是真的。但是我猜Sean并不知道我会打架。事实上我本可以对他下手更重一点，可能我真该这样子做。我想我大概会这样做，如果他去找告诉Small老师真相的那个孩子的麻烦。但是Sean从来没有找过他。所以，所有的一切就都忘记了。<br>&emsp;&emsp;走廊上一些同学很奇怪的看着我，因为我没有装饰我的储物柜，我是那个打了Sean，并且打完了之后无法停止哭泣的人。我猜我的情感非常的脆弱。<br>&emsp;&emsp;我变得很孤独，因为我的姐姐忙于成为家里最年长的孩子，我的哥哥忙于成为宾夕法尼亚州的橄榄球运动员。在训练营结束之后，他的教练说，他现在是二排队员，而当他开始学习相关系统知识时，他将成为首发球员。<br>&emsp;&emsp;我的爸爸非常希望哥哥能做到这些，然后为Steeler球队效力。我的妈妈很高兴，哥哥可以免费上大学，因为我的姐姐不打球，而我家没有足够的钱同时供他们俩上大学。这也是为什么她想让我努力学习，这样我就可以得到学业奖金。<br>&emsp;&emsp;那么，这就是我在高中还没交到朋友之前做的事了。我正希望那位说出真相的同学能够成为我的朋友，但我猜他说出真相的目的只是想做一个好人而已。<br>&emsp;&emsp;永远爱你的<br>&emsp;&emsp;Charlie</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;&lt;a href=&quot;http://pan.baidu.com/s/1c1OKADa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点此下载英文原著pdf版&lt;/a&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://ovrlh76oe.bkt.clouddn.com/%E5%B0%81%E9%9D%A2.jpg&quot; width=&quot;306&quot; height=&quot;213&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="写作" scheme="http://writinglife.vip/categories/%E5%86%99%E4%BD%9C/"/>
    
      <category term="壁花少年译" scheme="http://writinglife.vip/categories/%E5%86%99%E4%BD%9C/%E5%A3%81%E8%8A%B1%E5%B0%91%E5%B9%B4%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="http://writinglife.vip/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="壁花少年" scheme="http://writinglife.vip/tags/%E5%A3%81%E8%8A%B1%E5%B0%91%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>壁花少年（一）</title>
    <link href="http://writinglife.vip/2017/09/12/Wallflower/"/>
    <id>http://writinglife.vip/2017/09/12/Wallflower/</id>
    <published>2017-09-12T13:28:24.000Z</published>
    <updated>2017-09-12T14:40:16.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>&emsp;&emsp;最近看了一部青春文艺电影 “The Perks of Being a Wallflower” ，中文译作《壁花少年》。”wallflower”的意思是“舞会、聚会中坐在角落，无人问津的孩子”，指害羞而孤独的人。深深被电影中的配乐以及情节所吸引。于是我找来了英文原著，希望把小说读一遍，随之萌生了将其翻译成中文的想法。<br>&emsp;&emsp;翻译的过程中遇到了一些小困难，幸有英语大神 Vero 提出宝贵建议，在此鸣谢！<br>&emsp;&emsp;<a href="http://pan.baidu.com/s/1c1OKADa" target="_blank" rel="external">点此下载英文原著pdf版</a></p><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/%E5%B0%81%E9%9D%A2.jpg" width="306" height="213"><br></div><a id="more"></a><h2 id="壁花少年（一）"><a href="#壁花少年（一）" class="headerlink" title="壁花少年（一）"></a>壁花少年（一）</h2><p>&emsp;&emsp;1991.8.25<br>&emsp;&emsp;亲爱的朋友：<br>&emsp;&emsp;我给你写信是因为她说你善于倾听和理解他人，并且你不会尝试和在聚会上认识的人一夜风流，即使你有机会这样做。请你不要试图去调查她是谁，因为这样的话你可能会查到我是谁，而我真的不希望你知道我是谁。我将用不同的名字的或化名称呼可能出现在我信中的人，因为我不希望你找到我。我没有留下信的回复地址也是出于这个理由。我真诚地保证，我这样做没有任何恶意。<br>&emsp;&emsp;我只是需要知道，在我周围之外，有人倾听我，理解我，并且不会试图和遇到的人过夜，即使他们可以这样做。我需要知道，这样的人是存在的。<br>&emsp;&emsp;我觉得人海茫茫中你最理解我，因为我觉得你是个充满活力而热爱生活的人。至少我希望你是的。因为大家出于力量和友谊来找寻你，就这么简单。至少我听说是这样。<br>&emsp;&emsp;那么，说到我的生活，是悲喜交加的状态，我不知道为什么我会这样，而我也在继续寻找着答案。<br>&emsp;&emsp;我试图用家庭因素来解释这种状态，尤其是在我的朋友Michael在上个春天的某一天突然没有来学校之后，我们在广播里听到了Vaughn先生的声音：<br>&emsp;&emsp;“孩子们，我很遗憾的告知你们，我们中有一位同学离开了我们，我们将在周五为Michael举行一场悼念会”。<br>&emsp;&emsp;我不知道消息是如何在学校里传播的，而且为什么这些消息经常都是对的。可能是在吃午饭的食堂吧。这很难回忆了。但是Dave说Michael是自杀的。他的妈妈和邻居听到了枪声，那时候他们正在一起打桥牌。<br>&emsp;&emsp;我真的记不太清那之后发生的事情，除了我哥哥来到Vaughn的办公室安慰我不要再哭了。然后，他用手臂搂住我，对我说，在爸爸回来之前，不要再哭了。之后我们去麦当劳吃了炸薯条，他还教我怎么玩弹球。他还开玩笑说，因为我，他才可以在下午溜出学校。他还问我愿不愿意在他的科迈罗车上帮助他工作。我猜我一定非常低落，因为他以前从来不会让我呆在他的爱车里。<br>&emsp;&emsp;在和心理引导顾问们的谈话上，他们问我们，谁愿意上来说一说关于Michael的事。我觉得他们是害怕我们中有人会像Michael那样自杀或做一些其他的事，因为他们看起来非常紧张，其中有一位还一直捋自己的胡子。<br>&emsp;&emsp;疯疯癫癫的Bridget说，有时候电视看到一半进广告的时候，她就会想去死。她说的很真诚，让很疑惑。老好人Carl说他感到非常悲伤，但是他永远不会自杀，因为他认为这是一种罪孽。<br>&emsp;&emsp;有一个顾问穿过整个人群，最后走到我面前说：<br>&emsp;&emsp;“你怎么想的呢，Charlie?”<br>&emsp;&emsp;这令我很讶异，因为事实上我从没有见过这位先生，所谓的“专家”，可是他却知道我的名字，即使我并没有像他们一样戴着名牌。<br>&emsp;&emsp;“呃，我觉得Michael是一个很好的人，我不理解他为什么要自杀，我感觉到很悲伤，我觉得真正困扰我的事是我真的不懂他为什么这样做”<br>&emsp;&emsp;我又重复了一遍这段话，这听起来不像是我会说的话。尤其是在办公室中，因为我当时仍然在哭泣，我一直没有停止哭泣。<br>&emsp;&emsp;这位顾问说他怀疑Michael有家庭问题，他没有人可以诉说，这可能是他为什么觉得很孤单以至于最后自杀的原因。<br>&emsp;&emsp;然后，我开始声嘶力竭地对着顾问说，Michael本可以对我诉说。我开始哭的更伤心了。他尝试着让我平静下来，告诉我他的意思是Michael没有一个大人可以诉说，比如老师或者顾问。但是，这并不起作用，最后，我的哥哥开着他的科迈罗把我接走了。<br>&emsp;&emsp;这学年的剩下的时间，老师们对我特殊对待，他们给我更高的分数，尽管我丝毫没有变得更聪明。告诉你们真相，我觉得我把他们都弄焦虑了。<br>&emsp;&emsp;Michael的葬礼很奇怪，因为他的父亲没有哭。而就在三个月后，他离开了Michael的妈妈。至少Dave在午饭时间是这么告诉我的。我偶尔会想起这件事。我想知道在晚饭和电视剧的时间，Michael的家里会发生什么。Michael没有留下任何遗言，或者说，他的父母不让任何人看到这些。可能这是家庭问题。我希望我可以知道。这让我更加的思念他，让我产生悲伤的情绪。<br>&emsp;&emsp;我知道的事是，这让我自己会想，如果我有家庭问题会怎样，但是似乎相对于我来说，其他人的这种问题更严重。比如，当我姐姐的初恋男友开始和其它女孩约会时，我姐姐整整一个周末都以泪洗面。<br>&emsp;&emsp;我爸爸说，“这世上还有很多人的生活比这更艰难”。<br>&emsp;&emsp;我妈妈则一言不发。就这样，一个月以后，我姐姐遇到了另一个男孩，然后又开始听欢乐的音乐了。爸爸夜以继日地工作，妈妈如往常一样做着家务，哥哥继续修理着他的科迈罗，日子往复平淡无变化。直到初夏时节，哥哥离开家去了大学。他代表宾夕法尼亚州打橄榄球，但是为了打球，他需要好好利用这个暑假去提高他的成绩。<br>&emsp;&emsp;我不觉得我们家哪一个孩子最受宠。我们家有三个孩子，而我是最小的那个，我哥哥是最年长的。他是一个非常优秀的橄榄球运动员，很爱惜他的车。我的姐姐是初中生，她长得很漂亮，十分吸引男孩子的目光。我和我姐姐一样是全优生，这也是我为什么被同学们孤立的原因。<br>&emsp;&emsp;我妈妈经常在看电视节目的时候掉眼泪。我爸爸工作中勤勤恳恳，生活上诚实可靠。我的Helen阿姨过去说我爸爸实在太为自己的中年危机感到骄傲了。直到最近我才明白这些话的含义，因为他刚满四十岁，而什么都没有改变。<br>&emsp;&emsp;Helen阿姨是我在这个世界上最喜欢的人。她是我妈妈的妹妹。她年少时时全优生，过去常常拿书给我看。我爸爸说那些书对我而言还比较晦涩难懂，但我喜欢这些数，于是他只好耸耸肩，让我继续读。<br>&emsp;&emsp;在她生命的最后几年，Helen阿姨和我家人住在一起，因为她遭遇了非常不好的事。尽管我一直特别想知道到底发生了什么，但始终没人告诉我。大概在我七岁的时候，我不再问关于这件事的东西，因为每当我怕孩子气的问这问那，Helen阿姨就开始哭的特别伤心。<br>&emsp;&emsp;正当这时爸爸扇了我一巴掌，说，“你在伤害你的Helen阿姨的感情！”我并不想这样，所以我停止追问。Helen阿姨告诉我的爸爸，不要在她的面前打孩子，一次也不行。我爸爸说这是他的房子，他想怎么做就怎么做，此时妈妈在一旁缄默无言，我哥哥姐姐也是。<br>&emsp;&emsp;我哭的太厉害以至于那之后发生了什么我几乎想不起来。过了一会儿，我爸爸让妈妈把我带回房间。不久，我的妈妈在喝了几小杯白葡萄酒之后告诉我Helen阿姨发生了什么。有些人真的过的很惨，真的比我惨。<br>&emsp;&emsp;我现在应该去睡觉了。现在很晚了。我不知道我为什么会写下这么多文字给你看。我写这封信是因为我明天就要上高中了，而我真的很害怕。<br>&emsp;&emsp;永远爱你的<br>&emsp;&emsp;Charlie</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近看了一部青春文艺电影 “The Perks of Being a Wallflower” ，中文译作《壁花少年》。”wallflower”的意思是“舞会、聚会中坐在角落，无人问津的孩子”，指害羞而孤独的人。深深被电影中的配乐以及情节所吸引。于是我找来了英文原著，希望把小说读一遍，随之萌生了将其翻译成中文的想法。&lt;br&gt;&amp;emsp;&amp;emsp;翻译的过程中遇到了一些小困难，幸有英语大神 Vero 提出宝贵建议，在此鸣谢！&lt;br&gt;&amp;emsp;&amp;emsp;&lt;a href=&quot;http://pan.baidu.com/s/1c1OKADa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点此下载英文原著pdf版&lt;/a&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://ovrlh76oe.bkt.clouddn.com/%E5%B0%81%E9%9D%A2.jpg&quot; width=&quot;306&quot; height=&quot;213&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="写作" scheme="http://writinglife.vip/categories/%E5%86%99%E4%BD%9C/"/>
    
      <category term="壁花少年译" scheme="http://writinglife.vip/categories/%E5%86%99%E4%BD%9C/%E5%A3%81%E8%8A%B1%E5%B0%91%E5%B9%B4%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="http://writinglife.vip/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="壁花少年" scheme="http://writinglife.vip/tags/%E5%A3%81%E8%8A%B1%E5%B0%91%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建属于自己的博客</title>
    <link href="http://writinglife.vip/2017/09/04/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://writinglife.vip/2017/09/04/Hexo+GitHub搭建属于自己的博客/</id>
    <published>2017-09-04T13:38:26.000Z</published>
    <updated>2017-09-12T12:56:51.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何利用github-hexo搭建个人博客—纯小白入门教程"><a href="#如何利用github-hexo搭建个人博客—纯小白入门教程" class="headerlink" title="如何利用github+hexo搭建个人博客—纯小白入门教程"></a>如何利用github+hexo搭建个人博客—纯小白入门教程</h2><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>&emsp;生活的顿悟瞬间，学习上的点滴积累，工作上的零星灵感，这些不可多得的时刻，不写下来总是觉得可惜。尽管网上有那么多的平台，但总会想在无限的互联网中，能有那么一个只属于自己的空间。<br><br>&emsp;利用github+hexo可以很方便的搭建属于自己的个人博客，话不多说，下面大家跟着我一步步建立自己的个人博客吧！<br><a id="more"></a></p><h3 id="一、安装必要的程序"><a href="#一、安装必要的程序" class="headerlink" title="一、安装必要的程序"></a>一、安装必要的程序</h3><p>&emsp;需要安装的程序有：node.js、git、hexo，hexo在安装完前两个之后再安装。</p><h4 id="emsp-1-1-安装node-js"><a href="#emsp-1-1-安装node-js" class="headerlink" title="&emsp;1.1. 安装node.js"></a>&emsp;1.1. 安装node.js</h4><h4 id="emsp-emsp-安装步骤："><a href="#emsp-emsp-安装步骤：" class="headerlink" title="&emsp;&emsp;安装步骤："></a>&emsp;&emsp;安装步骤：</h4><p>&emsp;&emsp;1. 我安装的版本为v4.4.3，安装环境为win10,可以去官网下载：<br><a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a><br><br>也可以直接在点击下面下载，安装包下载地址：<br><br>32位安装包下载地址：<a href="https://nodejs.org/dist/v6.9.3/node-v6.9.3-x86.msi" target="_blank" rel="external">https://nodejs.org/dist/v6.9.3/node-v6.9.3-x86.msi</a><br><br>64位安装包下载地址：<a href="https://nodejs.org/dist/v6.9.3/node-v6.9.3-x64.msi" target="_blank" rel="external">https://nodejs.org/dist/v6.9.3/node-v6.9.3-x64.msi</a><br><br><br>&emsp;&emsp;2.双击刚刚下载的文件，然后一直点next就轻松安装完了</p><p><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/1.png" width="400" height="300"><br></div></p><p><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/2.png" width="400" height="300"><br></div><br><br></p><p><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/3.png" width="400" height="300"><br></div><br><br><br>接下来检测一下PATH环境变量中是否配置了Node.js，打开windows命令行工具，输入”path”。没有的话就手动配置一下系统的环境变量，很简单，自行百度~。<br><br></p><p><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/4.1.png" width="400" height="250"><br></div></p><h4 id="emsp-1-2-注册github账号及安装"><a href="#emsp-1-2-注册github账号及安装" class="headerlink" title="&emsp;1.2. 注册github账号及安装"></a>&emsp;1.2. 注册github账号及安装</h4><p>&emsp;&emsp;1. 首先需要去github上注册一个属于自己账号，已经有账号的跳过此步骤github官网传送门：<a href="https://github.com/" target="_blank" rel="external">https://github.com/</a>，点击”Sign up”按照提示一步步注册<br><br>&emsp;&emsp;2. git安装包下载地址:<a href="http://xiazai.sogou.com/detail/34/16/-4212831931637133254.html?e=1970" target="_blank" rel="external">git下载</a>，点击”普通下载”即可。接着点击下载的文件，按照提示一步步安装完。<br><br>&emsp;&emsp;注意：安装完之后可以打开电脑的命令行工具（点击电脑左下角windows图标–&gt;在搜索框输入”cmd”），输入”git”，若出现以下界面则表示安装成功<br><br></p><p><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/6.png" width="300" height="350"><br></div><br><br><br>反之，若出现如下提示：<br><br></p><p><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/7.png" width="300" height="100"><br></div><br><br><br>则说明环境变量没有配置，手动配置以下系统环境变量即可。</p><h4 id="emsp-1-3-安装hexo"><a href="#emsp-1-3-安装hexo" class="headerlink" title="&emsp;1.3. 安装hexo"></a>&emsp;1.3. 安装hexo</h4><p>&emsp;&emsp;安装完上面两个程序之后，hexo的安装会变得非常简单，打开安装好的”Git Bash”，输入<br></p><pre><code>$ sudo npm install -g hexo-cli</code></pre><p>耐心等待，直到提示安装完成。至此，搭建博客所需的三个程序全都安装好了，我们已经迈出了成功的第一步！</p><h3 id="二、在GitHub上搭建博客"><a href="#二、在GitHub上搭建博客" class="headerlink" title="二、在GitHub上搭建博客"></a>二、在GitHub上搭建博客</h3><h4 id="emsp-2-1-创建仓库Repositories"><a href="#emsp-2-1-创建仓库Repositories" class="headerlink" title="&emsp;2.1. 创建仓库Repositories"></a>&emsp;2.1. 创建仓库Repositories</h4><p>&emsp;&emsp;如下图，点击”New repository”<br><br></p><p><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/8.png" width="400" height="150"><br></div><br>&emsp;&emsp;配置参考如下：<br><br></p><p><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/9.png" width="400" height="320"><br></div><br>&emsp;&emsp;<strong>需要注意的地方</strong>：<br><br>&emsp;&emsp;仓库名必须是：<font color="orange"><strong>username.github.io</strong></font>，其中<font color="orange"><strong>username</strong></font>是你创建github账号时的用户名。<br><br>&emsp;&emsp;现在在地址栏输入:<a href="http:username.github.io" target="_blank" rel="external">http:username.github.io</a><br><br>&emsp;&emsp;会看到如下界面：<br><br></p><p><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/10.png" width="400" height="250"><br></div><br><br><br>&emsp;&emsp;别着急，出现这个界面是正常的，因为你还没有用到Hexo显示你的博客。</p><h4 id="emsp-2-2-配置SSH-key"><a href="#emsp-2-2-配置SSH-key" class="headerlink" title="&emsp;2.2. 配置SSH key"></a>&emsp;2.2. 配置SSH key</h4><p>&emsp;&emsp;配置SSH的目的是为了提交代码，可以选择直接输入用户名和密码，但这样会降低安全性（只要知道你的用户名和密码就可以修改你的代码）。因此我们选择使用ssh key来解决这个问题。<br><br>&emsp;&emsp;在git bash中执行如下命令：<br></p><pre><code>$ cd ~/. ssh </code></pre><p>&emsp;&emsp;如果提示：<font color="orange"><strong>No such file or directory</strong></font> 说明你是第一次使用git。继续</p><pre><code>ssh-keygen -t rsa -C &quot;你的邮件地址&quot;</code></pre><p>&emsp;&emsp;然后连续3次按回车，最终会在C:\Users\username.ssh下生成”id_rsa.pub”文件，打开并复制里面的内容，打开你的github主页，进入个人设置-&gt;SSH and GPG keys-&gt;New SSH key。title随便填，把刚刚复制的内容粘贴到key中。<br><br>&emsp;&emsp;现在测试一下SSH key是否配置成功：</p><pre><code>$ ssh -T 1017598314@qq.com //填写你的邮箱地址</code></pre><p>&emsp;&emsp;如果提示<font color="orange"><strong> Are you sure you want to continue connecting(yes/no)</strong></font>，输入yes，如果看到</p><blockquote><p>Hi XXXX!You’ ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>&emsp;&emsp;说明SSH已经配置成功。</p><h3 id="三、使用hexo"><a href="#三、使用hexo" class="headerlink" title="三、使用hexo"></a>三、使用hexo</h3><h4 id="emsp-3-1-hexo简介"><a href="#emsp-3-1-hexo简介" class="headerlink" title="&emsp;3.1. hexo简介"></a>&emsp;3.1. hexo简介</h4><p>&emsp;&emsp;Hexo是一个基于Github Pages的博客发布工具。<br><br>&emsp;&emsp;官网：<a href="http://hexo.io" target="_blank" rel="external">http://hexo.io</a><br><br>&emsp;&emsp;github：<a href="https://github.com/hexojs/hexo" target="_blank" rel="external">https://github.com/hexojs/hexo</a>    <br><br>&emsp;&emsp;想知道原理的可以在深入研究，这里我们只要会用就行。</p><h4 id="emsp-3-2-hexo安装"><a href="#emsp-3-2-hexo安装" class="headerlink" title="&emsp;3.2. hexo安装"></a>&emsp;3.2. hexo安装</h4><pre><code>$ npm install -g hexo</code></pre><h4 id="emsp-3-3-hexo初始化"><a href="#emsp-3-3-hexo初始化" class="headerlink" title="&emsp;3.3. hexo初始化"></a>&emsp;3.3. hexo初始化</h4><p>&emsp;&emsp;新建一个文件夹，用于存放代码，然后再git bash中先定到该文件夹，再对hexo进行初始化。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd /e/JavaWeb/Workspaces/hexo/ </div><div class="line">$ hexo init</div></pre></td></tr></table></figure></p><p>&emsp;&emsp;接着hexo会自动下载文件到这个目录，目录结构如图<br><br></p><p><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/11.png" width="400" height="250"><br></div><br><br><br>&emsp;&emsp;接下来执行生成和启动工作<br></p><pre><code>$ hexo g$ hexo s</code></pre><p>&emsp;&emsp;此时打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>，是不是已经加载出了hexo的界面！如果出现一直加载不出来的问题，不要着急，是你的4000端口被占用了，关闭一些在用的其他软件，重新生成和启动即可。<br><br></p><p><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/12.png" width="400" height="300"><br></div><br><br></p><h4 id="emsp-3-4-部署到github"><a href="#emsp-3-4-部署到github" class="headerlink" title="&emsp;3.4. 部署到github"></a>&emsp;3.4. 部署到github</h4><p>&emsp;&emsp;通过以上操作，访问 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>时，我们已经实现了一个像模像样的主页，但是这仅仅是在本地才能预览，实际上你的博客还没有放在网络上。因此我们需要把它部署到github上。<br><br>&emsp;&emsp;<strong>注意</strong>：hexo文件夹内有两种配置文件，文件名都是”_config.yml”。为了方便叙述，我把在根目录下的成为全局配置文件，把”themes”目录下的称为主题配置文件。<br><br>&emsp;&emsp;</p><ol><li>先Ctrl+C退出本地预览,打开全局配置文件，将”repo”这一项修改为github pages的地址<br><br><br><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/13.png" width="300" height="80"><br></div><br><br><br>&emsp;&emsp;</li><li><p>输入部署命令</p><p> $ hexo clean<br> $ hexo g<br> $ hexo d<br>在这个过程中会让你输入你的github账号及密码，部署成功后会出现下面的提示</p><blockquote><p> <a href="https://github.com/Birdziv/Birdziv.github.io.git" target="_blank" rel="external">https://github.com/Birdziv/Birdziv.github.io.git</a>.<br><br>INFO  Deploy done: git</p></blockquote></li></ol><p><br>&emsp;&emsp;现在打开<a href="http://Birdziv.github.io" target="_blank" rel="external">http://Birdziv.github.io</a> 是不是就可以访问刚刚出现的页面呢，不同的是，这次不是访问本机的资源了，也就意味着，你在任何地方上网，只要输入这个网址，就能登上自己的博客了！因为你已经将代码全部部署到github上了。</p><h3 id="四、选择自己喜欢的hexo主题"><a href="#四、选择自己喜欢的hexo主题" class="headerlink" title="四、选择自己喜欢的hexo主题"></a>四、选择自己喜欢的hexo主题</h3><p>&emsp;&emsp;hexo提供了非常多的主题，供我们选择–<a href="https://hexo.io/themes/" target="_blank" rel="external">hexo主题传送门</a></p><h4 id="emsp-4-1-配置NexT主题"><a href="#emsp-4-1-配置NexT主题" class="headerlink" title="&emsp;4.1. 配置NexT主题"></a>&emsp;4.1. 配置NexT主题</h4><p>&emsp;&emsp;NexT主题简约实用，是hexo所有主题中最受欢迎的主题之一–<a href="http://writinglife.vip/">点击我看效果</a><br><br>&emsp;&emsp;在此，我介绍一下NexT主题的配置    </p><h4 id="emsp-4-2-配置步骤"><a href="#emsp-4-2-配置步骤" class="headerlink" title="&emsp;4.2. 配置步骤"></a>&emsp;4.2. 配置步骤</h4><p>&emsp;&emsp;</p><ol><li><p>打开git bash，定位到hexo文件夹，并下载next主题的相关文件</p><p> $ cd /e/JavaWeb/Workspaces/hexo/<br> $ git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a> themes/next<br>&emsp;&emsp;这个过程不会太久，窗口可能会提示一些警告信息什么的，不用在意，只要最后提示的信息是完成就好。完成之后，会在theme文件夹里看到一个next文件夹。这时，进入全局配置文件_config.yml，找到 theme 字段，并将其值更改为 next<br><br><br><div align="center"><br><img src="http://ovrlh76oe.bkt.clouddn.com/15.png" width="300" height="50"><br></div><br><br><br>&emsp;&emsp;</p></li><li>配置好以后，我们重新生成hexo s，赶紧本地预览看一下效果吧<h4 id="emsp-4-3-hexo配置命令"><a href="#emsp-4-3-hexo配置命令" class="headerlink" title="&emsp;4.3. hexo配置命令"></a>&emsp;4.3. hexo配置命令</h4>&emsp;&emsp;牢记下面四个指令可以满足基本操作：<br><br>hexo s等同于hexo serve生成本地预览；<br><br>hexo clean清除本地生成的文件；<br><br>hexo g等同于hexo generate 生成最终的静态html文件；<br><br>hexo d等同于hexo deploy部署到github；<br><br>调用顺序：<br>每次我们修改了配置文件后，我们先hexo clean-&gt;hexo s-&gt;Ctrl+C-&gt;hexo g-&gt;hexo d.</li></ol><h3 id="五、最终效果"><a href="#五、最终效果" class="headerlink" title="五、最终效果"></a>五、最终效果</h3><p>&emsp;&emsp;最终效果我的博客：<a href="http://writinglife.vip/">http://writinglife.vip/</a>  刚刚搭建完成，虽然很简陋，但毕竟是自己一步步搭起来的，就像古时候自己盖房子一样。自己也在慢慢的完善，无论是内容还是博客的样式，以后有任何更新，都会在博客中写出来的。其实弄完，觉得还是挺有意思~</p><h3 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h3><p><a href="http://blog.liuxianan.com/build-blog-website-by-hexo-github.html" target="_blank" rel="external">http://blog.liuxianan.com/build-blog-website-by-hexo-github.html</a><br><a href="http://www.jianshu.com/p/a4b74cc9ff28" target="_blank" rel="external">http://www.jianshu.com/p/a4b74cc9ff28</a></p><h3 id="七、待完善的地方"><a href="#七、待完善的地方" class="headerlink" title="七、待完善的地方"></a>七、待完善的地方</h3><p>&emsp;&emsp;评论功能，阅读统计功能，搜索功能……博主自己也在慢慢学习中……希望我们都能在浩瀚网络中拥有自己的一块舒适精致的天空</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何利用github-hexo搭建个人博客—纯小白入门教程&quot;&gt;&lt;a href=&quot;#如何利用github-hexo搭建个人博客—纯小白入门教程&quot; class=&quot;headerlink&quot; title=&quot;如何利用github+hexo搭建个人博客—纯小白入门教程&quot;&gt;&lt;/a&gt;如何利用github+hexo搭建个人博客—纯小白入门教程&lt;/h2&gt;&lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;&amp;emsp;生活的顿悟瞬间，学习上的点滴积累，工作上的零星灵感，这些不可多得的时刻，不写下来总是觉得可惜。尽管网上有那么多的平台，但总会想在无限的互联网中，能有那么一个只属于自己的空间。&lt;br&gt;&lt;br&gt;&amp;emsp;利用github+hexo可以很方便的搭建属于自己的个人博客，话不多说，下面大家跟着我一步步建立自己的个人博客吧！&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Hexo" scheme="http://writinglife.vip/categories/%E5%AD%A6%E4%B9%A0/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://writinglife.vip/tags/Hexo/"/>
    
      <category term="GitHub" scheme="http://writinglife.vip/tags/GitHub/"/>
    
  </entry>
  
</feed>
